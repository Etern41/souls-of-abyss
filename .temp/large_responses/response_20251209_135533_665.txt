
<TOOL_RUN>
{"tool_call_id": "call_I7Ar7SU25QFAoYWzoN4iWQys", "name": "ToolListFiles", "args": {"folder": ".", "mask": "*"}}
</TOOL_RUN>


<TOOL_RESULT>
{"tool_call_id": "call_I7Ar7SU25QFAoYWzoN4iWQys", "name": "ToolListFiles", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"Folder project root content:\\n\\\\GAME-DESIGN.md\\n\\\\PROJECT-MANAGEMENT.md\\n\\\\PROMPTS.md\\n\\\\README.md\\n\\\\meta\\\\plans\\\\build-skeleton.md\"}], \"action_name\": \"ToolListFiles\", \"message\": \"Action 'ToolListFiles' completed successfully\"}", "content_length": 283, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"Folder project root content:\\n\\\\GAME-DESIGN.md\\n\\\\PROJECT-MANAGEMENT.md\\n\\\\PROMPTS.md\\n\\\\README.md\\n\\\\meta\\\\plans\\\\build-skeleton.md\"}], \"action_name\": \"ToolListFiles\", \"message\": \"Action 'ToolListFiles' completed successfully\"}", "rejected": false}
</TOOL_RESULT>



<TOOL_RUN>
{"tool_call_id": "call_6zJ8mE7ScUjBvtH345z4sUc0", "name": "ToolTextFileEdit", "args": {"short_description": "Add complete Souls of the Abyss game.js implementation", "filename": "game.js", "old_text": "", "new_text": "class Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  clone() {\n    return new Vector2(this.x, this.y);\n  }\n\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n\n  subtract(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  normalize() {\n    const len = this.length() || 1;\n    this.x /= len;\n    this.y /= len;\n    return this;\n  }\n\n  distance(other) {\n    const dx = this.x - other.x;\n    const dy = this.y - other.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angle(other) {\n    return Math.atan2(other.y - this.y, other.x - this.x);\n  }\n\n  static fromAngle(angle, magnitude = 1) {\n    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\n  }\n}\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 600;\nconst TARGET_DELTA = 1 / 60;\nconst DEG_TO_RAD = Math.PI / 180;\nconst DEFAULT_ANIMATION = {\n  animations: {\n    idle: { frameCount: 1, frameTime: 1, loop: true },\n    run: { frameCount: 1, frameTime: 1, loop: true },\n    attack: { frameCount: 1, frameTime: 1, loop: false },\n    hit: { frameCount: 1, frameTime: 1, loop: false },\n    death: { frameCount: 1, frameTime: 1, loop: false }\n  }\n};\n\nconst CHARACTER_DEFS = {\n  knight: {\n    maxHealth: 100,\n    baseDamage: 12,\n    range: 110,\n    speed: 200,\n    armor: 5,\n    spriteSize: 48\n  },\n  witch: {\n    maxHealth: 70,\n    baseDamage: 8,\n    range: 140,\n    speed: 180,\n    armor: 2,\n    spriteSize: 48\n  },\n  rogue: {\n    maxHealth: 85,\n    baseDamage: 10,\n    range: 90,\n    speed: 250,\n    armor: 3,\n    spriteSize: 48,\n    dodgeChance: 0.1\n  }\n};\n\nconst ENEMY_DEFS = {\n  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\n  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\n  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\n  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\n  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\n  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\n  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\n};\n\nconst BOSS_DEFS = {\n  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\n  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\n  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\n};\n\nconst SOUL_TYPES = {\n  ethereal: { xp: 10, color: '#f3f6ff' },\n  essence: { xp: 0, color: '#ffd95a', essence: 1 },\n  corrupted: { xp: 20, color: '#b21f35' },\n  cursed: { xp: 50, color: '#0d0d0d' }\n};\n\nconst LEVEL_WEAPON_UNLOCK = [\n  'ShatterburstAxe',\n  'SoulreaverDagger',\n  'EternalHalberd',\n  'ChaosOrb',\n  'ReapersScythe',\n  'BloodmoonLance',\n  'VoidSummoner'\n];\n\nconst spriteCache = {};\nconst animationCache = {};\n\nfunction getAnimationPath(name) {\n  return `animations/${name}.json`;\n}\n\nfunction getSprite(name, spriteSize = 48) {\n  if (spriteCache[name]) {\n    return spriteCache[name];\n  }\n  const sprite = new Sprite(\n    name,\n    `sprites/${name}.png`,\n    spriteSize,\n    spriteSize,\n    getAnimationPath(name)\n  );\n  spriteCache[name] = sprite;\n  return sprite;\n}\n\nfunction loadAnimationData(name) {\n  if (animationCache[name]) {\n    return animationCache[name];\n  }\n  animationCache[name] = DEFAULT_ANIMATION;\n  fetch(getAnimationPath(name))\n    .then((resp) => resp.json())\n    .then((data) => {\n      animationCache[name] = data.animations ? data : { animations: data };\n    })\n    .catch(() => {\n      animationCache[name] = DEFAULT_ANIMATION;\n    });\n  return animationCache[name];\n}\n\nclass Sprite {\n  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\n    this.name = name;\n    this.image = new Image();\n    this.image.src = imageUrl;\n    this.imageLoaded = false;\n    this.imageFailed = false;\n    this.image.onload = () => {\n      this.imageLoaded = true;\n    };\n    this.image.onerror = () => {\n      this.imageFailed = true;\n    };\n    this.frameWidth = frameWidth;\n    this.frameHeight = frameHeight;\n    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\n    this.currentState = 'idle';\n    this.animationTime = 0;\n    this.frameIndex = 0;\n    this.colorFallback = '#ffffff';\n    this.animationPath = animationPath;\n    this.refreshAnimation();\n  }\n\n  refreshAnimation() {\n    fetch(this.animationPath)\n      .then((resp) => resp.json())\n      .then((data) => {\n        this.animationData = data.animations ? data : { animations: data };\n      })\n      .catch(() => {\n        this.animationData = DEFAULT_ANIMATION;\n      });\n  }\n\n  update(dt, desiredState = 'idle') {\n    if (this.currentState !== desiredState) {\n      this.currentState = desiredState;\n      this.animationTime = 0;\n    } else {\n      this.animationTime += dt;\n    }\n    const animSpec = this.getAnimationSpec(this.currentState);\n    const totalDuration = animSpec.frameCount * animSpec.frameTime;\n    if (animSpec.loop) {\n      this.animationTime = this.animationTime % (totalDuration || 1);\n    } else if (this.animationTime > totalDuration) {\n      this.animationTime = totalDuration - animSpec.frameTime;\n    }\n    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\n  }\n\n  getAnimationSpec(state) {\n    const data = this.animationData.animations || this.animationData;\n    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\n  }\n\n  draw(ctx, x, y, scale = 1, flipX = false) {\n    if (this.imageLoaded && !this.imageFailed) {\n      const animSpec = this.getAnimationSpec(this.currentState);\n      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\n      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\n      const srcY = 0;\n      const destWidth = this.frameWidth * scale;\n      const destHeight = this.frameHeight * scale;\n      ctx.save();\n      if (flipX) {\n        ctx.translate(x + destWidth, y);\n        ctx.scale(-1, 1);\n        ctx.drawImage(\n          this.image,\n          srcX,\n          srcY,\n          this.frameWidth,\n          this.frameHeight,\n          0,\n          0,\n          destWidth,\n          destHeight\n        );\n      } else {\n        ctx.drawImage(\n          this.image,\n          srcX,\n          srcY,\n          this.frameWidth,\n          this.frameHeight,\n          x,\n          y,\n          destWidth,\n          destHeight\n        );\n      }\n      ctx.restore();\n    } else {\n      ctx.fillStyle = this.colorFallback;\n      ctx.beginPath();\n      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n}\n\nclass Particle {\n  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\n    this.position = new Vector2(x, y);\n    this.velocity = new Vector2(vx, vy);\n    this.lifetime = lifetime;\n    this.remaining = lifetime;\n    this.color = color;\n    this.type = type;\n    this.size = type === 'explosion' ? 10 : 4;\n  }\n\n  update(dt) {\n    this.remaining -= dt;\n    if (this.type === 'blood' || this.type === 'spark') {\n      this.velocity.y += 30 * dt;\n    }\n    this.position.add(this.velocity.clone().scale(dt));\n  }\n\n  draw(ctx) {\n    if (this.remaining <= 0) {\n      return;\n    }\n    const alpha = Math.max(this.remaining / this.lifetime, 0);\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    if (this.type === 'glow') {\n      const gradient = ctx.createRadialGradient(\n        this.position.x,\n        this.position.y,\n        0,\n        this.position.x,\n        this.position.y,\n        this.size * 2\n      );\n      gradient.addColorStop(0, this.color);\n      gradient.addColorStop(1, 'transparent');\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\n      ctx.fill();\n    } else {\n      ctx.fillStyle = this.color;\n      ctx.beginPath();\n      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n}\n\nclass Projectile {\n  constructor(config) {\n    this.position = config.position.clone();\n    this.velocity = config.velocity.clone();\n    this.damage = config.damage;\n    this.range = config.range;\n    this.traveled = 0;\n    this.radius = config.radius || 6;\n    this.pierce = config.pierce || 1;\n    this.owner = config.owner;\n    this.lifesteal = config.lifesteal || 0;\n    this.color = config.color || '#ffffff';\n  }\n\n  update(dt) {\n    const movement = this.velocity.clone().scale(dt);\n    this.position.add(movement);\n    this.traveled += movement.length();\n  }\n\n  isExpired() {\n    return this.traveled >= this.range;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nclass Soul {\n  constructor(x, y, type) {\n    this.position = new Vector2(x, y);\n    this.type = type;\n    this.radius = 8;\n    this.floatTimer = 0;\n    this.collected = false;\n  }\n\n  update(dt, player) {\n    this.floatTimer += dt;\n    const bob = Math.sin(this.floatTimer * 3) * 2;\n    if (player && player.position.distance(this.position) < 25) {\n      this.collected = true;\n      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\n      if (SOUL_TYPES[this.type].essence) {\n        grantEssence(SOUL_TYPES[this.type].essence);\n      }\n    }\n    this.renderOffset = bob;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = SOUL_TYPES[this.type].color;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nclass Weapon {\n  constructor(name, config) {\n    this.name = name;\n    this.damage = config.damage;\n    this.fireRate = config.fireRate || 1;\n    this.range = config.range || 100;\n    this.type = config.type;\n    this.cost = config.cost || 0;\n    this.manual = config.manual || false;\n    this.cooldown = 0;\n    this.execute = config.execute;\n    this.lifesteal = config.lifesteal || 0;\n    this.extra = config.extra || {};\n  }\n\n  update(dt, player, enemies) {\n    if (this.manual) {\n      return;\n    }\n    this.cooldown -= dt;\n    if (this.cooldown <= 0) {\n      const fired = this.execute(player, enemies, this);\n      if (fired) {\n        this.cooldown = 1 / this.fireRate;\n      }\n    }\n  }\n\n  trigger(player, enemies) {\n    return this.execute(player, enemies, this);\n  }\n}\n\nclass Enemy {\n  constructor(type, x, y, isBoss = false) {\n    this.type = type;\n    this.isBoss = isBoss;\n    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\n    this.maxHealth = this.definition.health;\n    this.health = this.maxHealth;\n    this.damage = this.definition.damage;\n    this.speed = this.definition.speed;\n    this.position = new Vector2(x, y);\n    this.velocity = new Vector2();\n    this.alive = true;\n    this.state = 'idle';\n    this.deathTimer = 0;\n    this.sprite = getSprite(type, this.definition.spriteSize || 48);\n    this.sprite.colorFallback = this.definition.color;\n  }\n\n  update(dt, player, multiplier) {\n    if (!this.alive) {\n      this.deathTimer += dt;\n      this.sprite.update(dt, 'death');\n      return;\n    }\n    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\n    const distance = Math.max(toPlayer.length(), 0.0001);\n    const direction = toPlayer.clone().scale(1 / distance);\n    const effectiveSpeed = this.speed * multiplier;\n    if (this.type === 'wraith') {\n      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\n      direction.add(swirl).normalize();\n    }\n    this.velocity = direction.clone().scale(effectiveSpeed);\n    this.position.add(this.velocity.clone().scale(dt));\n    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\n  }\n\n  takeDamage(amount) {\n    if (!this.alive) {\n      return false;\n    }\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n      this.state = 'death';\n      return true;\n    }\n    this.state = 'hit';\n    return false;\n  }\n\n  draw(ctx) {\n    const size = this.definition.spriteSize || 48;\n    const drawX = this.position.x - size * 0.5;\n    const drawY = this.position.y - size * 0.5;\n    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\n    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\n    if (this.alive) {\n      ctx.fillStyle = '#222';\n      ctx.fillRect(drawX, drawY - 10, size, 4);\n      ctx.fillStyle = '#e63946';\n      const hpRatio = Math.max(this.health / this.maxHealth, 0);\n      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\n    }\n  }\n}\n\nclass Player {\n  constructor(character) {\n    const def = CHARACTER_DEFS[character];\n    this.character = character;\n    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n    this.velocity = new Vector2();\n    this.speed = def.speed;\n    this.range = def.range;\n    this.maxHealth = def.maxHealth;\n    this.health = def.maxHealth;\n    this.baseDamage = def.baseDamage;\n    this.level = 1;\n    this.experience = 0;\n    this.nextLevelExp = 100;\n    this.armor = def.armor || 0;\n    this.sprite = getSprite(character, def.spriteSize);\n    this.sprite.colorFallback = '#f5f3f4';\n    this.state = 'idle';\n    this.killStreak = 0;\n    this.killStreakTimer = 0;\n    this.killStreakActive = false;\n    this.killStreakDuration = 5;\n    this.weapons = [];\n    this.manualWeapons = {};\n    this.unlockWeapon('CursedBlade');\n    this.unlockWeapon('GodsayerSword');\n    this.unlockWeapon('ShatterburstAxe');\n    this.unlockWeapon('SoulreaverDagger');\n    this.unlockWeapon('EternalHalberd');\n    this.unlockWeapon('ChaosOrb');\n    this.unlockWeapon('ReapersScythe');\n    this.unlockWeapon('BloodmoonLance');\n    this.unlockWeapon('VoidSummoner');\n    this.weapons = this.weapons.filter((w) => !w.manual);\n    this.sprite.refreshAnimation();\n  }\n\n  unlockWeapon(name) {\n    if (!WEAPON_CONFIGS[name]) {\n      return;\n    }\n    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\n    if (weapon.manual) {\n      this.manualWeapons[name] = weapon;\n    } else {\n      this.weapons.push(weapon);\n    }\n  }\n\n  update(dt, state) {\n    const keys = state.keys;\n    const input = new Vector2(\n      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\n      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\n    );\n    if (input.length() > 0) {\n      input.normalize();\n      this.velocity = input.clone().scale(this.speed);\n      this.state = 'run';\n    } else {\n      this.velocity = new Vector2();\n      this.state = 'idle';\n    }\n    this.position.add(this.velocity.clone().scale(dt));\n    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\n    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\n    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\n    if (this.killStreakActive) {\n      this.killStreakTimer -= dt;\n      if (this.killStreakTimer <= 0) {\n        this.killStreakActive = false;\n        this.killStreak = 0;\n      }\n    }\n    this.sprite.update(dt, this.state);\n  }\n\n  takeDamage(amount) {\n    if (this.character === 'rogue' && Math.random() < 0.1) {\n      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\n      return;\n    }\n    const mitigated = Math.max(amount - this.armor, 1);\n    this.health -= mitigated;\n    if (this.health <= 0) {\n      this.health = 0;\n      gameState.alive = false;\n    }\n  }\n\n  gainExperience(amount) {\n    this.experience += amount;\n    while (this.experience >= this.nextLevelExp) {\n      this.experience -= this.nextLevelExp;\n      this.level += 1;\n      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\n      this.maxHealth += 5;\n      this.health = this.maxHealth;\n      if (this.character === 'knight') {\n        this.armor += 1;\n      }\n      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\n        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\n        if (weaponName) {\n          this.unlockWeapon(weaponName);\n        }\n      }\n    }\n  }\n\n  registerKill() {\n    this.killStreak += 1;\n    if (this.character === 'rogue' && this.killStreak >= 5) {\n      this.killStreakActive = true;\n      this.killStreakTimer = this.killStreakDuration;\n    }\n  }\n\n  getDamageMultiplier() {\n    let multiplier = 1 + (this.level - 1) * 0.05;\n    if (this.killStreakActive) {\n      multiplier += 0.15;\n    }\n    return multiplier;\n  }\n\n  draw(ctx) {\n    const size = CHARACTER_DEFS[this.character].spriteSize;\n    const drawX = this.position.x - size * 0.5;\n    const drawY = this.position.y - size * 0.5;\n    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\n    ctx.fillStyle = '#222';\n    ctx.fillRect(drawX, drawY - 12, size, 5);\n    ctx.fillStyle = '#7cf5ff';\n    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\n  }\n}\n\nconst WEAPON_CONFIGS = {\n  CursedBlade: {\n    damage: 10,\n    fireRate: 1,\n    range: 100,\n    type: 'cone',\n    execute: (player, enemies, weapon) => {\n      let hit = false;\n      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) {\n          return;\n        }\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const angleToEnemy = Math.atan2(\n            enemy.position.y - player.position.y,\n            enemy.position.x - player.position.x\n          );\n          let delta = angleToEnemy - facingAngle;\n          while (delta > Math.PI) delta -= Math.PI * 2;\n          while (delta < -Math.PI) delta += Math.PI * 2;\n          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            hit = hit || killed;\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n          }\n        }\n      });\n      if (hit) {\n        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\n      }\n      return true;\n    }\n  },\n  ShatterburstAxe: {\n    damage: 15,\n    fireRate: 0.8,\n    range: 60,\n    type: 'aoe',\n    execute: (player, enemies, weapon) => {\n      let any = false;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        if (player.position.distance(enemy.position) <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          any = any || killed;\n          if (killed) {\n            handleEnemyDeath(enemy);\n          } else {\n            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\n            enemy.position.add(push);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\n      return true;\n    }\n  },\n  SoulreaverDagger: {\n    damage: 5,\n    fireRate: 2,\n    range: 30,\n    type: 'multi-hit',\n    execute: (player, enemies, weapon) => {\n      let target = null;\n      let closest = Infinity;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance < closest && distance <= weapon.range) {\n          closest = distance;\n          target = enemy;\n        }\n      });\n      if (!target) {\n        return false;\n      }\n      for (let i = 0; i < 3; i += 1) {\n        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\n        if (killed) {\n          handleEnemyDeath(target);\n          break;\n        }\n        player.health = Math.min(\n          player.maxHealth,\n          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\n        );\n      }\n      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\n      return true;\n    }\n  },\n  EternalHalberd: {\n    damage: 25,\n    fireRate: 0.5,\n    range: 80,\n    type: 'aoe',\n    execute: (player, enemies, weapon) => {\n      let hitAny = false;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          hitAny = hitAny || killed;\n          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\n          enemy.position.add(pull.scale(0.1));\n          if (killed) {\n            handleEnemyDeath(enemy);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\n      return true;\n    }\n  },\n  ChaosOrb: {\n    damage: 8,\n    fireRate: 1.2,\n    range: 300,\n    type: 'projectile',\n    execute: (player) => {\n      const orbCount = 2 + Math.floor(Math.random() * 3);\n      for (let i = 0; i < orbCount; i += 1) {\n        const angle = Math.random() * Math.PI * 2;\n        const velocity = Vector2.fromAngle(angle, 200);\n        gameState.projectiles.push(\n          new Projectile({\n            position: player.position.clone(),\n            velocity,\n            damage: 8 * player.getDamageMultiplier(),\n            range: 320,\n            pierce: 3,\n            owner: player,\n            color: '#7bed9f'\n          })\n        );\n      }\n      return true;\n    }\n  },\n  ReapersScythe: {\n    damage: 20,\n    fireRate: 0.8,\n    range: 100,\n    type: 'spin',\n    execute: (player, enemies, weapon) => {\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          if (killed) {\n            handleEnemyDeath(enemy);\n          } else {\n            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\n            enemy.position.add(pull);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\n      return true;\n    }\n  },\n  BloodmoonLance: {\n    damage: 20,\n    fireRate: 1,\n    range: 400,\n    type: 'beam',\n    lifesteal: 0.5,\n    execute: (player, enemies, weapon) => {\n      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const toEnemy = enemy.position.clone().subtract(player.position);\n        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\n        if (projection >= 0 && projection <= weapon.range) {\n          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\n          if (perpendicular <= 40) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n            player.health = Math.min(\n              player.maxHealth,\n              player.health + weapon.damage * weapon.lifesteal\n            );\n          }\n        }\n      });\n      spawnParticleBurst(\n        player.position.x + direction.x * 60,\n        player.position.y + direction.y * 60,\n        '#ff99c8',\n        'glow',\n        14\n      );\n      return true;\n    }\n  },\n  GodsayerSword: {\n    damage: 100,\n    fireRate: 1,\n    range: 150,\n    type: 'manual',\n    manual: true,\n    cost: 1,\n    execute: (player, enemies, weapon) => {\n      if (gameState.weaponCharges < weapon.cost) {\n        return false;\n      }\n      gameState.weaponCharges -= weapon.cost;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        if (player.position.distance(enemy.position) <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          if (killed) {\n            handleEnemyDeath(enemy);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\n      triggerScreenShake();\n      return true;\n    }\n  },\n  VoidSummoner: {\n    damage: 15,\n    fireRate: 0.125,\n    range: 200,\n    cost: 2,\n    type: 'summon',\n    execute: (player, enemies, weapon) => {\n      if (gameState.weaponCharges < weapon.cost) {\n        return false;\n      }\n      gameState.weaponCharges -= weapon.cost;\n      for (let i = 0; i < 3; i += 1) {\n        const angle = (Math.PI * 2 * i) / 3;\n        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\n        enemies.forEach((enemy) => {\n          if (!enemy.alive) return;\n          if (summonPos.distance(enemy.position) <= 70) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n          }\n        });\n        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\n      }\n      return true;\n    }\n  }\n};\n\nconst gameState = {\n  canvas: null,\n  ctx: null,\n  player: null,\n  enemies: [],\n  souls: [],\n  particles: [],\n  projectiles: [],\n  alive: false,\n  keys: { w: false, a: false, s: false, d: false },\n  gameTime: 0,\n  waveTimer: 0,\n  waveNumber: 0,\n  bossTimer: 0,\n  bossIndex: 0,\n  enemiesKilled: 0,\n  difficultyMultiplier: 1,\n  weaponCharges: 0,\n  essenceCollected: 0,\n  pendingGodsayer: false,\n  screenShake: 0,\n  lastTimestamp: performance.now()\n};\n\nfunction ensureCanvas() {\n  if (!gameState.canvas) {\n    gameState.canvas = document.getElementById('gameCanvas');\n    if (gameState.canvas) {\n      gameState.ctx = gameState.canvas.getContext('2d');\n    }\n  }\n}\n\nfunction initGame(character = 'knight') {\n  ensureCanvas();\n  gameState.player = new Player(character);\n  gameState.enemies = [];\n  gameState.souls = [];\n  gameState.particles = [];\n  gameState.projectiles = [];\n  gameState.gameTime = 0;\n  gameState.waveTimer = 0;\n  gameState.waveNumber = 0;\n  gameState.bossTimer = 0;\n  gameState.enemiesKilled = 0;\n  gameState.weaponCharges = 0;\n  gameState.essenceCollected = 0;\n  gameState.alive = true;\n  gameState.screenShake = 0;\n}\n\nfunction spawnWave() {\n  if (!gameState.player) {\n    return;\n  }\n  const count = 5 + gameState.waveNumber * 2;\n  for (let i = 0; i < count; i += 1) {\n    const isElite = Math.random() < 0.2;\n    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\n    const type = pool[Math.floor(Math.random() * pool.length)];\n    const angle = Math.random() * Math.PI * 2;\n    const spawnRadius = 150 + Math.random() * 100;\n    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\n    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\n    gameState.enemies.push(new Enemy(type, posX, posY));\n  }\n  gameState.waveNumber += 1;\n  gameState.waveTimer = 0;\n}\n\nfunction spawnBoss() {\n  const bossKeys = Object.keys(BOSS_DEFS);\n  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\n  gameState.bossIndex += 1;\n  const edge = Math.floor(Math.random() * 4);\n  let x = 0;\n  let y = 0;\n  if (edge === 0) {\n    x = Math.random() * CANVAS_WIDTH;\n    y = -50;\n  } else if (edge === 1) {\n    x = CANVAS_WIDTH + 50;\n    y = Math.random() * CANVAS_HEIGHT;\n  } else if (edge === 2) {\n    x = Math.random() * CANVAS_WIDTH;\n    y = CANVAS_HEIGHT + 50;\n  } else {\n    x = -50;\n    y = Math.random() * CANVAS_HEIGHT;\n  }\n  const boss = new Enemy(bossName, x, y, true);\n  gameState.enemies.push(boss);\n  gameState.bossTimer = 0;\n  triggerScreenShake(20);\n}\n\nfunction grantEssence(amount) {\n  gameState.essenceCollected += amount;\n  if (gameState.essenceCollected >= 5) {\n    const charges = Math.floor(gameState.essenceCollected / 5);\n    gameState.weaponCharges += charges;\n    gameState.essenceCollected -= charges * 5;\n  }\n}\n\nfunction handleEnemyDeath(enemy) {\n  if (!enemy) {\n    return;\n  }\n  gameState.enemiesKilled += 1;\n  if (gameState.player) {\n    gameState.player.registerKill();\n  }\n  dropSoul(enemy);\n  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\n}\n\nfunction dropSoul(enemy) {\n  if (enemy.isBoss) {\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\n    return;\n  }\n  if (ENEMY_DEFS[enemy.type].elite) {\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\n    if (Math.random() < 0.4) {\n      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\n    }\n  } else {\n    if (Math.random() < 0.95) {\n      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\n    }\n    if (Math.random() < 0.05) {\n      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\n    }\n  }\n}\n\nfunction spawnParticleBurst(x, y, color, type, count) {\n  for (let i = 0; i < count; i += 1) {\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 40 + Math.random() * 120;\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\n    gameState.particles.push(particle);\n  }\n}\n\nfunction triggerScreenShake(intensity = 10) {\n  gameState.screenShake = Math.max(gameState.screenShake, intensity);\n}\n\nfunction updateProjectiles(dt) {\n  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\n    const projectile = gameState.projectiles[i];\n    projectile.update(dt);\n    let removed = false;\n    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\n      const enemy = gameState.enemies[j];\n      if (!enemy.alive) continue;\n      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\n        const killed = enemy.takeDamage(projectile.damage);\n        if (killed) {\n          handleEnemyDeath(enemy);\n        }\n        projectile.pierce -= 1;\n        if (projectile.lifesteal && gameState.player) {\n          gameState.player.health = Math.min(\n            gameState.player.maxHealth,\n            gameState.player.health + projectile.damage * projectile.lifesteal\n          );\n        }\n        if (projectile.pierce <= 0) {\n          removed = true;\n          break;\n        }\n      }\n    }\n    if (projectile.isExpired() || removed) {\n      gameState.projectiles.splice(i, 1);\n    }\n  }\n}\n\nfunction updateSouls(dt) {\n  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\n    const soul = gameState.souls[i];\n    soul.update(dt, gameState.player);\n    if (soul.collected) {\n      gameState.souls.splice(i, 1);\n    }\n  }\n}\n\nfunction updateParticles(dt) {\n  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\n    const particle = gameState.particles[i];\n    particle.update(dt);\n    if (particle.remaining <= 0) {\n      gameState.particles.splice(i, 1);\n    }\n  }\n}\n\nfunction updateEnemies(dt) {\n  const player = gameState.player;\n  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\n    const enemy = gameState.enemies[i];\n    enemy.update(dt, player, gameState.difficultyMultiplier);\n    if (!enemy.alive && enemy.deathTimer > 1.5) {\n      gameState.enemies.splice(i, 1);\n    }\n    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\n      const damage = enemy.damage;\n      player.takeDamage(damage);\n      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\n    }\n  }\n}\n\nfunction triggerGodsayerSword() {\n  if (!gameState.player) {\n    return false;\n  }\n  const weapon = gameState.player.manualWeapons.GodsayerSword;\n  if (!weapon) {\n    return false;\n  }\n  return weapon.trigger(gameState.player, gameState.enemies);\n}\n\nfunction gameLoop(dt) {\n  ensureCanvas();\n  if (!gameState.ctx) {\n    return;\n  }\n  if (gameState.player && gameState.alive) {\n    gameState.gameTime += dt;\n    gameState.waveTimer += dt;\n    gameState.bossTimer += dt;\n    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\n    gameState.player.update(dt, gameState);\n    updateEnemies(dt);\n    updateProjectiles(dt);\n    updateSouls(dt);\n    updateParticles(dt);\n    if (gameState.waveTimer >= 30) {\n      spawnWave();\n    }\n    if (gameState.bossTimer >= 120) {\n      spawnBoss();\n    }\n    if (gameState.player.health <= 0) {\n      gameState.alive = false;\n    }\n  }\n  drawGame();\n  notifyHUD();\n}\n\nfunction drawGame() {\n  const ctx = gameState.ctx;\n  if (!ctx) {\n    return;\n  }\n  ctx.save();\n  if (gameState.screenShake > 0) {\n    ctx.translate(\n      (Math.random() - 0.5) * gameState.screenShake,\n      (Math.random() - 0.5) * gameState.screenShake\n    );\n    gameState.screenShake *= 0.9;\n  }\n  drawBackground(ctx);\n  gameState.souls.forEach((soul) => soul.draw(ctx));\n  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\n  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\n  if (gameState.player) {\n    gameState.player.draw(ctx);\n  }\n  gameState.particles.forEach((particle) => particle.draw(ctx));\n  drawHUDOverlay(ctx);\n  ctx.restore();\n}\n\nfunction drawBackground(ctx) {\n  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\n  gradient.addColorStop(0, '#1a0327');\n  gradient.addColorStop(0.5, '#1f1f49');\n  gradient.addColorStop(1, '#040308');\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\n  for (let i = 0; i < 8; i += 1) {\n    const angle = (Math.PI * 2 * i) / 8;\n    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\n    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\n    ctx.stroke();\n  }\n  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\n  ctx.beginPath();\n  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\n  ctx.stroke();\n}\n\nfunction drawHUDOverlay(ctx) {\n  if (!gameState.player) {\n    return;\n  }\n  ctx.fillStyle = 'rgba(0,0,0,0.35)';\n  ctx.fillRect(15, 15, 220, 110);\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '14px \"Segoe UI\", sans-serif';\n  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\n  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\n  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\n  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\n  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\n  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\n}\n\nfunction notifyHUD() {\n  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\n    window.updateHUD(gameState);\n  }\n  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\n    window.showDeathScreen(gameState);\n  }\n}\n\nfunction animationLoop(timestamp) {\n  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\n  gameState.lastTimestamp = timestamp;\n  gameLoop(dt || TARGET_DELTA);\n  window.requestAnimationFrame(animationLoop);\n}\n\nwindow.requestAnimationFrame(animationLoop);\n\nfunction setKeyState(key, isDown) {\n  if (gameState.keys[key] !== undefined) {\n    gameState.keys[key] = isDown;\n  }\n}\n\nwindow.initGame = initGame;\nwindow.triggerGodsayerSword = triggerGodsayerSword;\nwindow.setKeyState = setKeyState;\nwindow.gameState = gameState;\nwindow.spawnWave = spawnWave;\nwindow.spawnBoss = spawnBoss;\nwindow.grantEssence = grantEssence;\nwindow.handleEnemyDeath = handleEnemyDeath;\nwindow.triggerScreenShake = triggerScreenShake;\n", "preview_only": "false", "skip_validation": "false"}}
</TOOL_RUN>

<TOOL_RESULT>
{"tool_call_id": "call_6zJ8mE7ScUjBvtH345z4sUc0", "name": "ToolTextFileEdit", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -0,0 +1,1236 @@\\n+class Vector2 {\\n+  constructor(x = 0, y = 0) {\\n+    this.x = x;\\n+    this.y = y;\\n+  }\\n+\\n+  clone() {\\n+    return new Vector2(this.x, this.y);\\n+  }\\n+\\n+  add(v) {\\n+    this.x += v.x;\\n+    this.y += v.y;\\n+    return this;\\n+  }\\n+\\n+  subtract(v) {\\n+    this.x -= v.x;\\n+    this.y -= v.y;\\n+    return this;\\n+  }\\n+\\n+  scale(s) {\\n+    this.x *= s;\\n+    this.y *= s;\\n+    return this;\\n+  }\\n+\\n+  length() {\\n+    return Math.sqrt(this.x * this.x + this.y * this.y);\\n+  }\\n+\\n+  normalize() {\\n+    const len = this.length() || 1;\\n+    this.x /= len;\\n+    this.y /= len;\\n+    return this;\\n+  }\\n+\\n+  distance(other) {\\n+    const dx = this.x - other.x;\\n+    const dy = this.y - other.y;\\n+    return Math.sqrt(dx * dx + dy * dy);\\n+  }\\n+\\n+  angle(other) {\\n+    return Math.atan2(other.y - this.y, other.x - this.x);\\n+  }\\n+\\n+  static fromAngle(angle, magnitude = 1) {\\n+    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\\n+  }\\n+}\\n+\\n+const CANVAS_WIDTH = 1000;\\n+const CANVAS_HEIGHT = 600;\\n+const TARGET_DELTA = 1 / 60;\\n+const DEG_TO_RAD = Math.PI / 180;\\n+const DEFAULT_ANIMATION = {\\n+  animations: {\\n+    idle: { frameCount: 1, frameTime: 1, loop: true },\\n+    run: { frameCount: 1, frameTime: 1, loop: true },\\n+    attack: { frameCount: 1, frameTime: 1, loop: false },\\n+    hit: { frameCount: 1, frameTime: 1, loop: false },\\n+    death: { frameCount: 1, frameTime: 1, loop: false }\\n+  }\\n+};\\n+\\n+const CHARACTER_DEFS = {\\n+  knight: {\\n+    maxHealth: 100,\\n+    baseDamage: 12,\\n+    range: 110,\\n+    speed: 200,\\n+    armor: 5,\\n+    spriteSize: 48\\n+  },\\n+  witch: {\\n+    maxHealth: 70,\\n+    baseDamage: 8,\\n+    range: 140,\\n+    speed: 180,\\n+    armor: 2,\\n+    spriteSize: 48\\n+  },\\n+  rogue: {\\n+    maxHealth: 85,\\n+    baseDamage: 10,\\n+    range: 90,\\n+    speed: 250,\\n+    armor: 3,\\n+    spriteSize: 48,\\n+    dodgeChance: 0.1\\n+  }\\n+};\\n+\\n+const ENEMY_DEFS = {\\n+  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\\n+  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\\n+  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\\n+  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\\n+  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\\n+  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\\n+  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\\n+};\\n+\\n+const BOSS_DEFS = {\\n+  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\\n+  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\\n+  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\\n+};\\n+\\n+const SOUL_TYPES = {\\n+  ethereal: { xp: 10, color: '#f3f6ff' },\\n+  essence: { xp: 0, color: '#ffd95a', essence: 1 },\\n+  corrupted: { xp: 20, color: '#b21f35' },\\n+  cursed: { xp: 50, color: '#0d0d0d' }\\n+};\\n+\\n+const LEVEL_WEAPON_UNLOCK = [\\n+  'ShatterburstAxe',\\n+  'SoulreaverDagger',\\n+  'EternalHalberd',\\n+  'ChaosOrb',\\n+  'ReapersScythe',\\n+  'BloodmoonLance',\\n+  'VoidSummoner'\\n+];\\n+\\n+const spriteCache = {};\\n+const animationCache = {};\\n+\\n+function getAnimationPath(name) {\\n+  return `animations/${name}.json`;\\n+}\\n+\\n+function getSprite(name, spriteSize = 48) {\\n+  if (spriteCache[name]) {\\n+    return spriteCache[name];\\n+  }\\n+  const sprite = new Sprite(\\n+    name,\\n+    `sprites/${name}.png`,\\n+    spriteSize,\\n+    spriteSize,\\n+    getAnimationPath(name)\\n+  );\\n+  spriteCache[name] = sprite;\\n+  return sprite;\\n+}\\n+\\n+function loadAnimationData(name) {\\n+  if (animationCache[name]) {\\n+    return animationCache[name];\\n+  }\\n+  animationCache[name] = DEFAULT_ANIMATION;\\n+  fetch(getAnimationPath(name))\\n+    .then((resp) => resp.json())\\n+    .then((data) => {\\n+      animationCache[name] = data.animations ? data : { animations: data };\\n+    })\\n+    .catch(() => {\\n+      animationCache[name] = DEFAULT_ANIMATION;\\n+    });\\n+  return animationCache[name];\\n+}\\n+\\n+class Sprite {\\n+  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\\n+    this.name = name;\\n+    this.image = new Image();\\n+    this.image.src = imageUrl;\\n+    this.imageLoaded = false;\\n+    this.imageFailed = false;\\n+    this.image.onload = () => {\\n+      this.imageLoaded = true;\\n+    };\\n+    this.image.onerror = () => {\\n+      this.imageFailed = true;\\n+    };\\n+    this.frameWidth = frameWidth;\\n+    this.frameHeight = frameHeight;\\n+    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\\n+    this.currentState = 'idle';\\n+    this.animationTime = 0;\\n+    this.frameIndex = 0;\\n+    this.colorFallback = '#ffffff';\\n+    this.animationPath = animationPath;\\n+    this.refreshAnimation();\\n+  }\\n+\\n+  refreshAnimation() {\\n+    fetch(this.animationPath)\\n+      .then((resp) => resp.json())\\n+      .then((data) => {\\n+        this.animationData = data.animations ? data : { animations: data };\\n+      })\\n+      .catch(() => {\\n+        this.animationData = DEFAULT_ANIMATION;\\n+      });\\n+  }\\n+\\n+  update(dt, desiredState = 'idle') {\\n+    if (this.currentState !== desiredState) {\\n+      this.currentState = desiredState;\\n+      this.animationTime = 0;\\n+    } else {\\n+      this.animationTime += dt;\\n+    }\\n+    const animSpec = this.getAnimationSpec(this.currentState);\\n+    const totalDuration = animSpec.frameCount * animSpec.frameTime;\\n+    if (animSpec.loop) {\\n+      this.animationTime = this.animationTime % (totalDuration || 1);\\n+    } else if (this.animationTime > totalDuration) {\\n+      this.animationTime = totalDuration - animSpec.frameTime;\\n+    }\\n+    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\\n+  }\\n+\\n+  getAnimationSpec(state) {\\n+    const data = this.animationData.animations || this.animationData;\\n+    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\\n+  }\\n+\\n+  draw(ctx, x, y, scale = 1, flipX = false) {\\n+    if (this.imageLoaded && !this.imageFailed) {\\n+      const animSpec = this.getAnimationSpec(this.currentState);\\n+      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\\n+      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\\n+      const srcY = 0;\\n+      const destWidth = this.frameWidth * scale;\\n+      const destHeight = this.frameHeight * scale;\\n+      ctx.save();\\n+      if (flipX) {\\n+        ctx.translate(x + destWidth, y);\\n+        ctx.scale(-1, 1);\\n+        ctx.drawImage(\\n+          this.image,\\n+          srcX,\\n+          srcY,\\n+          this.frameWidth,\\n+          this.frameHeight,\\n+          0,\\n+          0,\\n+          destWidth,\\n+          destHeight\\n+        );\\n+      } else {\\n+        ctx.drawImage(\\n+          this.image,\\n+          srcX,\\n+          srcY,\\n+          this.frameWidth,\\n+          this.frameHeight,\\n+          x,\\n+          y,\\n+          destWidth,\\n+          destHeight\\n+        );\\n+      }\\n+      ctx.restore();\\n+    } else {\\n+      ctx.fillStyle = this.colorFallback;\\n+      ctx.beginPath();\\n+      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    }\\n+  }\\n+}\\n+\\n+class Particle {\\n+  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\\n+    this.position = new Vector2(x, y);\\n+    this.velocity = new Vector2(vx, vy);\\n+    this.lifetime = lifetime;\\n+    this.remaining = lifetime;\\n+    this.color = color;\\n+    this.type = type;\\n+    this.size = type === 'explosion' ? 10 : 4;\\n+  }\\n+\\n+  update(dt) {\\n+    this.remaining -= dt;\\n+    if (this.type === 'blood' || this.type === 'spark') {\\n+      this.velocity.y += 30 * dt;\\n+    }\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+  }\\n+\\n+  draw(ctx) {\\n+    if (this.remaining <= 0) {\\n+      return;\\n+    }\\n+    const alpha = Math.max(this.remaining / this.lifetime, 0);\\n+    ctx.save();\\n+    ctx.globalAlpha = alpha;\\n+    if (this.type === 'glow') {\\n+      const gradient = ctx.createRadialGradient(\\n+        this.position.x,\\n+        this.position.y,\\n+        0,\\n+        this.position.x,\\n+        this.position.y,\\n+        this.size * 2\\n+      );\\n+      gradient.addColorStop(0, this.color);\\n+      gradient.addColorStop(1, 'transparent');\\n+      ctx.fillStyle = gradient;\\n+      ctx.beginPath();\\n+      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    } else {\\n+      ctx.fillStyle = this.color;\\n+      ctx.beginPath();\\n+      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    }\\n+    ctx.restore();\\n+  }\\n+}\\n+\\n+class Projectile {\\n+  constructor(config) {\\n+    this.position = config.position.clone();\\n+    this.velocity = config.velocity.clone();\\n+    this.damage = config.damage;\\n+    this.range = config.range;\\n+    this.traveled = 0;\\n+    this.radius = config.radius || 6;\\n+    this.pierce = config.pierce || 1;\\n+    this.owner = config.owner;\\n+    this.lifesteal = config.lifesteal || 0;\\n+    this.color = config.color || '#ffffff';\\n+  }\\n+\\n+  update(dt) {\\n+    const movement = this.velocity.clone().scale(dt);\\n+    this.position.add(movement);\\n+    this.traveled += movement.length();\\n+  }\\n+\\n+  isExpired() {\\n+    return this.traveled >= this.range;\\n+  }\\n+\\n+  draw(ctx) {\\n+    ctx.fillStyle = this.color;\\n+    ctx.beginPath();\\n+    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\\n+    ctx.fill();\\n+  }\\n+}\\n+\\n+class Soul {\\n+  constructor(x, y, type) {\\n+    this.position = new Vector2(x, y);\\n+    this.type = type;\\n+    this.radius = 8;\\n+    this.floatTimer = 0;\\n+    this.collected = false;\\n+  }\\n+\\n+  update(dt, player) {\\n+    this.floatTimer += dt;\\n+    const bob = Math.sin(this.floatTimer * 3) * 2;\\n+    if (player && player.position.distance(this.position) < 25) {\\n+      this.collected = true;\\n+      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\\n+      if (SOUL_TYPES[this.type].essence) {\\n+        grantEssence(SOUL_TYPES[this.type].essence);\\n+      }\\n+    }\\n+    this.renderOffset = bob;\\n+  }\\n+\\n+  draw(ctx) {\\n+    ctx.fillStyle = SOUL_TYPES[this.type].color;\\n+    ctx.beginPath();\\n+    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\\n+    ctx.fill();\\n+  }\\n+}\\n+\\n+class Weapon {\\n+  constructor(name, config) {\\n+    this.name = name;\\n+    this.damage = config.damage;\\n+    this.fireRate = config.fireRate || 1;\\n+    this.range = config.range || 100;\\n+    this.type = config.type;\\n+    this.cost = config.cost || 0;\\n+    this.manual = config.manual || false;\\n+    this.cooldown = 0;\\n+    this.execute = config.execute;\\n+    this.lifesteal = config.lifesteal || 0;\\n+    this.extra = config.extra || {};\\n+  }\\n+\\n+  update(dt, player, enemies) {\\n+    if (this.manual) {\\n+      return;\\n+    }\\n+    this.cooldown -= dt;\\n+    if (this.cooldown <= 0) {\\n+      const fired = this.execute(player, enemies, this);\\n+      if (fired) {\\n+        this.cooldown = 1 / this.fireRate;\\n+      }\\n+    }\\n+  }\\n+\\n+  trigger(player, enemies) {\\n+    return this.execute(player, enemies, this);\\n+  }\\n+}\\n+\\n+class Enemy {\\n+  constructor(type, x, y, isBoss = false) {\\n+    this.type = type;\\n+    this.isBoss = isBoss;\\n+    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\\n+    this.maxHealth = this.definition.health;\\n+    this.health = this.maxHealth;\\n+    this.damage = this.definition.damage;\\n+    this.speed = this.definition.speed;\\n+    this.position = new Vector2(x, y);\\n+    this.velocity = new Vector2();\\n+    this.alive = true;\\n+    this.state = 'idle';\\n+    this.deathTimer = 0;\\n+    this.sprite = getSprite(type, this.definition.spriteSize || 48);\\n+    this.sprite.colorFallback = this.definition.color;\\n+  }\\n+\\n+  update(dt, player, multiplier) {\\n+    if (!this.alive) {\\n+      this.deathTimer += dt;\\n+      this.sprite.update(dt, 'death');\\n+      return;\\n+    }\\n+    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\\n+    const distance = Math.max(toPlayer.length(), 0.0001);\\n+    const direction = toPlayer.clone().scale(1 / distance);\\n+    const effectiveSpeed = this.speed * multiplier;\\n+    if (this.type === 'wraith') {\\n+      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\\n+      direction.add(swirl).normalize();\\n+    }\\n+    this.velocity = direction.clone().scale(effectiveSpeed);\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\\n+  }\\n+\\n+  takeDamage(amount) {\\n+    if (!this.alive) {\\n+      return false;\\n+    }\\n+    this.health -= amount;\\n+    if (this.health <= 0) {\\n+      this.alive = false;\\n+      this.state = 'death';\\n+      return true;\\n+    }\\n+    this.state = 'hit';\\n+    return false;\\n+  }\\n+\\n+  draw(ctx) {\\n+    const size = this.definition.spriteSize || 48;\\n+    const drawX = this.position.x - size * 0.5;\\n+    const drawY = this.position.y - size * 0.5;\\n+    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\\n+    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\\n+    if (this.alive) {\\n+      ctx.fillStyle = '#222';\\n+      ctx.fillRect(drawX, drawY - 10, size, 4);\\n+      ctx.fillStyle = '#e63946';\\n+      const hpRatio = Math.max(this.health / this.maxHealth, 0);\\n+      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\\n+    }\\n+  }\\n+}\\n+\\n+class Player {\\n+  constructor(character) {\\n+    const def = CHARACTER_DEFS[character];\\n+    this.character = character;\\n+    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\\n+    this.velocity = new Vector2();\\n+    this.speed = def.speed;\\n+    this.range = def.range;\\n+    this.maxHealth = def.maxHealth;\\n+    this.health = def.maxHealth;\\n+    this.baseDamage = def.baseDamage;\\n+    this.level = 1;\\n+    this.experience = 0;\\n+    this.nextLevelExp = 100;\\n+    this.armor = def.armor || 0;\\n+    this.sprite = getSprite(character, def.spriteSize);\\n+    this.sprite.colorFallback = '#f5f3f4';\\n+    this.state = 'idle';\\n+    this.killStreak = 0;\\n+    this.killStreakTimer = 0;\\n+    this.killStreakActive = false;\\n+    this.killStreakDuration = 5;\\n+    this.weapons = [];\\n+    this.manualWeapons = {};\\n+    this.unlockWeapon('CursedBlade');\\n+    this.unlockWeapon('GodsayerSword');\\n+    this.unlockWeapon('ShatterburstAxe');\\n+    this.unlockWeapon('SoulreaverDagger');\\n+    this.unlockWeapon('EternalHalberd');\\n+    this.unlockWeapon('ChaosOrb');\\n+    this.unlockWeapon('ReapersScythe');\\n+    this.unlockWeapon('BloodmoonLance');\\n+    this.unlockWeapon('VoidSummoner');\\n+    this.weapons = this.weapons.filter((w) => !w.manual);\\n+    this.sprite.refreshAnimation();\\n+  }\\n+\\n+  unlockWeapon(name) {\\n+    if (!WEAPON_CONFIGS[name]) {\\n+      return;\\n+    }\\n+    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\\n+    if (weapon.manual) {\\n+      this.manualWeapons[name] = weapon;\\n+    } else {\\n+      this.weapons.push(weapon);\\n+    }\\n+  }\\n+\\n+  update(dt, state) {\\n+    const keys = state.keys;\\n+    const input = new Vector2(\\n+      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\\n+      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\\n+    );\\n+    if (input.length() > 0) {\\n+      input.normalize();\\n+      this.velocity = input.clone().scale(this.speed);\\n+      this.state = 'run';\\n+    } else {\\n+      this.velocity = new Vector2();\\n+      this.state = 'idle';\\n+    }\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\\n+    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\\n+    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\\n+    if (this.killStreakActive) {\\n+      this.killStreakTimer -= dt;\\n+      if (this.killStreakTimer <= 0) {\\n+        this.killStreakActive = false;\\n+        this.killStreak = 0;\\n+      }\\n+    }\\n+    this.sprite.update(dt, this.state);\\n+  }\\n+\\n+  takeDamage(amount) {\\n+    if (this.character === 'rogue' && Math.random() < 0.1) {\\n+      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\\n+      return;\\n+    }\\n+    const mitigated = Math.max(amount - this.armor, 1);\\n+    this.health -= mitigated;\\n+    if (this.health <= 0) {\\n+      this.health = 0;\\n+      gameState.alive = false;\\n+    }\\n+  }\\n+\\n+  gainExperience(amount) {\\n+    this.experience += amount;\\n+    while (this.experience >= this.nextLevelExp) {\\n+      this.experience -= this.nextLevelExp;\\n+      this.level += 1;\\n+      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\\n+      this.maxHealth += 5;\\n+      this.health = this.maxHealth;\\n+      if (this.character === 'knight') {\\n+        this.armor += 1;\\n+      }\\n+      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\\n+        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\\n+        if (weaponName) {\\n+          this.unlockWeapon(weaponName);\\n+        }\\n+      }\\n+    }\\n+  }\\n+\\n+  registerKill() {\\n+    this.killStreak += 1;\\n+    if (this.character === 'rogue' && this.killStreak >= 5) {\\n+      this.killStreakActive = true;\\n+      this.killStreakTimer = this.killStreakDuration;\\n+    }\\n+  }\\n+\\n+  getDamageMultiplier() {\\n+    let multiplier = 1 + (this.level - 1) * 0.05;\\n+    if (this.killStreakActive) {\\n+      multiplier += 0.15;\\n+    }\\n+    return multiplier;\\n+  }\\n+\\n+  draw(ctx) {\\n+    const size = CHARACTER_DEFS[this.character].spriteSize;\\n+    const drawX = this.position.x - size * 0.5;\\n+    const drawY = this.position.y - size * 0.5;\\n+    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\\n+    ctx.fillStyle = '#222';\\n+    ctx.fillRect(drawX, drawY - 12, size, 5);\\n+    ctx.fillStyle = '#7cf5ff';\\n+    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\\n+  }\\n+}\\n+\\n+const WEAPON_CONFIGS = {\\n+  CursedBlade: {\\n+    damage: 10,\\n+    fireRate: 1,\\n+    range: 100,\\n+    type: 'cone',\\n+    execute: (player, enemies, weapon) => {\\n+      let hit = false;\\n+      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) {\\n+          return;\\n+        }\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const angleToEnemy = Math.atan2(\\n+            enemy.position.y - player.position.y,\\n+            enemy.position.x - player.position.x\\n+          );\\n+          let delta = angleToEnemy - facingAngle;\\n+          while (delta > Math.PI) delta -= Math.PI * 2;\\n+          while (delta < -Math.PI) delta += Math.PI * 2;\\n+          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            hit = hit || killed;\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+          }\\n+        }\\n+      });\\n+      if (hit) {\\n+        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\\n+      }\\n+      return true;\\n+    }\\n+  },\\n+  ShatterburstAxe: {\\n+    damage: 15,\\n+    fireRate: 0.8,\\n+    range: 60,\\n+    type: 'aoe',\\n+    execute: (player, enemies, weapon) => {\\n+      let any = false;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        if (player.position.distance(enemy.position) <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          any = any || killed;\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          } else {\\n+            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\\n+            enemy.position.add(push);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\\n+      return true;\\n+    }\\n+  },\\n+  SoulreaverDagger: {\\n+    damage: 5,\\n+    fireRate: 2,\\n+    range: 30,\\n+    type: 'multi-hit',\\n+    execute: (player, enemies, weapon) => {\\n+      let target = null;\\n+      let closest = Infinity;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance < closest && distance <= weapon.range) {\\n+          closest = distance;\\n+          target = enemy;\\n+        }\\n+      });\\n+      if (!target) {\\n+        return false;\\n+      }\\n+      for (let i = 0; i < 3; i += 1) {\\n+        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+        if (killed) {\\n+          handleEnemyDeath(target);\\n+          break;\\n+        }\\n+        player.health = Math.min(\\n+          player.maxHealth,\\n+          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\\n+        );\\n+      }\\n+      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\\n+      return true;\\n+    }\\n+  },\\n+  EternalHalberd: {\\n+    damage: 25,\\n+    fireRate: 0.5,\\n+    range: 80,\\n+    type: 'aoe',\\n+    execute: (player, enemies, weapon) => {\\n+      let hitAny = false;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          hitAny = hitAny || killed;\\n+          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\\n+          enemy.position.add(pull.scale(0.1));\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\\n+      return true;\\n+    }\\n+  },\\n+  ChaosOrb: {\\n+    damage: 8,\\n+    fireRate: 1.2,\\n+    range: 300,\\n+    type: 'projectile',\\n+    execute: (player) => {\\n+      const orbCount = 2 + Math.floor(Math.random() * 3);\\n+      for (let i = 0; i < orbCount; i += 1) {\\n+        const angle = Math.random() * Math.PI * 2;\\n+        const velocity = Vector2.fromAngle(angle, 200);\\n+        gameState.projectiles.push(\\n+          new Projectile({\\n+            position: player.position.clone(),\\n+            velocity,\\n+            damage: 8 * player.getDamageMultiplier(),\\n+            range: 320,\\n+            pierce: 3,\\n+            owner: player,\\n+            color: '#7bed9f'\\n+          })\\n+        );\\n+      }\\n+      return true;\\n+    }\\n+  },\\n+  ReapersScythe: {\\n+    damage: 20,\\n+    fireRate: 0.8,\\n+    range: 100,\\n+    type: 'spin',\\n+    execute: (player, enemies, weapon) => {\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          } else {\\n+            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\\n+            enemy.position.add(pull);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\\n+      return true;\\n+    }\\n+  },\\n+  BloodmoonLance: {\\n+    damage: 20,\\n+    fireRate: 1,\\n+    range: 400,\\n+    type: 'beam',\\n+    lifesteal: 0.5,\\n+    execute: (player, enemies, weapon) => {\\n+      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const toEnemy = enemy.position.clone().subtract(player.position);\\n+        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\\n+        if (projection >= 0 && projection <= weapon.range) {\\n+          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\\n+          if (perpendicular <= 40) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+            player.health = Math.min(\\n+              player.maxHealth,\\n+              player.health + weapon.damage * weapon.lifesteal\\n+            );\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(\\n+        player.position.x + direction.x * 60,\\n+        player.position.y + direction.y * 60,\\n+        '#ff99c8',\\n+        'glow',\\n+        14\\n+      );\\n+      return true;\\n+    }\\n+  },\\n+  GodsayerSword: {\\n+    damage: 100,\\n+    fireRate: 1,\\n+    range: 150,\\n+    type: 'manual',\\n+    manual: true,\\n+    cost: 1,\\n+    execute: (player, enemies, weapon) => {\\n+      if (gameState.weaponCharges < weapon.cost) {\\n+        return false;\\n+      }\\n+      gameState.weaponCharges -= weapon.cost;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        if (player.position.distance(enemy.position) <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\\n+      triggerScreenShake();\\n+      return true;\\n+    }\\n+  },\\n+  VoidSummoner: {\\n+    damage: 15,\\n+    fireRate: 0.125,\\n+    range: 200,\\n+    cost: 2,\\n+    type: 'summon',\\n+    execute: (player, enemies, weapon) => {\\n+      if (gameState.weaponCharges < weapon.cost) {\\n+        return false;\\n+      }\\n+      gameState.weaponCharges -= weapon.cost;\\n+      for (let i = 0; i < 3; i += 1) {\\n+        const angle = (Math.PI * 2 * i) / 3;\\n+        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\\n+        enemies.forEach((enemy) => {\\n+          if (!enemy.alive) return;\\n+          if (summonPos.distance(enemy.position) <= 70) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+          }\\n+        });\\n+        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\\n+      }\\n+      return true;\\n+    }\\n+  }\\n+};\\n+\\n+const gameState = {\\n+  canvas: null,\\n+  ctx: null,\\n+  player: null,\\n+  enemies: [],\\n+  souls: [],\\n+  particles: [],\\n+  projectiles: [],\\n+  alive: false,\\n+  keys: { w: false, a: false, s: false, d: false },\\n+  gameTime: 0,\\n+  waveTimer: 0,\\n+  waveNumber: 0,\\n+  bossTimer: 0,\\n+  bossIndex: 0,\\n+  enemiesKilled: 0,\\n+  difficultyMultiplier: 1,\\n+  weaponCharges: 0,\\n+  essenceCollected: 0,\\n+  pendingGodsayer: false,\\n+  screenShake: 0,\\n+  lastTimestamp: performance.now()\\n+};\\n+\\n+function ensureCanvas() {\\n+  if (!gameState.canvas) {\\n+    gameState.canvas = document.getElementById('gameCanvas');\\n+    if (gameState.canvas) {\\n+      gameState.ctx = gameState.canvas.getContext('2d');\\n+    }\\n+  }\\n+}\\n+\\n+function initGame(character = 'knight') {\\n+  ensureCanvas();\\n+  gameState.player = new Player(character);\\n+  gameState.enemies = [];\\n+  gameState.souls = [];\\n+  gameState.particles = [];\\n+  gameState.projectiles = [];\\n+  gameState.gameTime = 0;\\n+  gameState.waveTimer = 0;\\n+  gameState.waveNumber = 0;\\n+  gameState.bossTimer = 0;\\n+  gameState.enemiesKilled = 0;\\n+  gameState.weaponCharges = 0;\\n+  gameState.essenceCollected = 0;\\n+  gameState.alive = true;\\n+  gameState.screenShake = 0;\\n+}\\n+\\n+function spawnWave() {\\n+  if (!gameState.player) {\\n+    return;\\n+  }\\n+  const count = 5 + gameState.waveNumber * 2;\\n+  for (let i = 0; i < count; i += 1) {\\n+    const isElite = Math.random() < 0.2;\\n+    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\\n+    const type = pool[Math.floor(Math.random() * pool.length)];\\n+    const angle = Math.random() * Math.PI * 2;\\n+    const spawnRadius = 150 + Math.random() * 100;\\n+    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\\n+    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\\n+    gameState.enemies.push(new Enemy(type, posX, posY));\\n+  }\\n+  gameState.waveNumber += 1;\\n+  gameState.waveTimer = 0;\\n+}\\n+\\n+function spawnBoss() {\\n+  const bossKeys = Object.keys(BOSS_DEFS);\\n+  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\\n+  gameState.bossIndex += 1;\\n+  const edge = Math.floor(Math.random() * 4);\\n+  let x = 0;\\n+  let y = 0;\\n+  if (edge === 0) {\\n+    x = Math.random() * CANVAS_WIDTH;\\n+    y = -50;\\n+  } else if (edge === 1) {\\n+    x = CANVAS_WIDTH + 50;\\n+    y = Math.random() * CANVAS_HEIGHT;\\n+  } else if (edge === 2) {\\n+    x = Math.random() * CANVAS_WIDTH;\\n+    y = CANVAS_HEIGHT + 50;\\n+  } else {\\n+    x = -50;\\n+    y = Math.random() * CANVAS_HEIGHT;\\n+  }\\n+  const boss = new Enemy(bossName, x, y, true);\\n+  gameState.enemies.push(boss);\\n+  gameState.bossTimer = 0;\\n+  triggerScreenShake(20);\\n+}\\n+\\n+function grantEssence(amount) {\\n+  gameState.essenceCollected += amount;\\n+  if (gameState.essenceCollected >= 5) {\\n+    const charges = Math.floor(gameState.essenceCollected / 5);\\n+    gameState.weaponCharges += charges;\\n+    gameState.essenceCollected -= charges * 5;\\n+  }\\n+}\\n+\\n+function handleEnemyDeath(enemy) {\\n+  if (!enemy) {\\n+    return;\\n+  }\\n+  gameState.enemiesKilled += 1;\\n+  if (gameState.player) {\\n+    gameState.player.registerKill();\\n+  }\\n+  dropSoul(enemy);\\n+  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\\n+}\\n+\\n+function dropSoul(enemy) {\\n+  if (enemy.isBoss) {\\n+    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\\n+    return;\\n+  }\\n+  if (ENEMY_DEFS[enemy.type].elite) {\\n+    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\\n+    if (Math.random() < 0.4) {\\n+      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\\n+    }\\n+  } else {\\n+    if (Math.random() < 0.95) {\\n+      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\\n+    }\\n+    if (Math.random() < 0.05) {\\n+      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\\n+    }\\n+  }\\n+}\\n+\\n+function spawnParticleBurst(x, y, color, type, count) {\\n+  for (let i = 0; i < count; i += 1) {\\n+    const angle = Math.random() * Math.PI * 2;\\n+    const speed = 40 + Math.random() * 120;\\n+    const vx = Math.cos(angle) * speed;\\n+    const vy = Math.sin(angle) * speed;\\n+    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\\n+    gameState.particles.push(particle);\\n+  }\\n+}\\n+\\n+function triggerScreenShake(intensity = 10) {\\n+  gameState.screenShake = Math.max(gameState.screenShake, intensity);\\n+}\\n+\\n+function updateProjectiles(dt) {\\n+  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\\n+    const projectile = gameState.projectiles[i];\\n+    projectile.update(dt);\\n+    let removed = false;\\n+    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\\n+      const enemy = gameState.enemies[j];\\n+      if (!enemy.alive) continue;\\n+      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\\n+        const killed = enemy.takeDamage(projectile.damage);\\n+        if (killed) {\\n+          handleEnemyDeath(enemy);\\n+        }\\n+        projectile.pierce -= 1;\\n+        if (projectile.lifesteal && gameState.player) {\\n+          gameState.player.health = Math.min(\\n+            gameState.player.maxHealth,\\n+            gameState.player.health + projectile.damage * projectile.lifesteal\\n+          );\\n+        }\\n+        if (projectile.pierce <= 0) {\\n+          removed = true;\\n+          break;\\n+        }\\n+      }\\n+    }\\n+    if (projectile.isExpired() || removed) {\\n+      gameState.projectiles.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateSouls(dt) {\\n+  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\\n+    const soul = gameState.souls[i];\\n+    soul.update(dt, gameState.player);\\n+    if (soul.collected) {\\n+      gameState.souls.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateParticles(dt) {\\n+  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\\n+    const particle = gameState.particles[i];\\n+    particle.update(dt);\\n+    if (particle.remaining <= 0) {\\n+      gameState.particles.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateEnemies(dt) {\\n+  const player = gameState.player;\\n+  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\\n+    const enemy = gameState.enemies[i];\\n+    enemy.update(dt, player, gameState.difficultyMultiplier);\\n+    if (!enemy.alive && enemy.deathTimer > 1.5) {\\n+      gameState.enemies.splice(i, 1);\\n+    }\\n+    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\\n+      const damage = enemy.damage;\\n+      player.takeDamage(damage);\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\\n+    }\\n+  }\\n+}\\n+\\n+function triggerGodsayerSword() {\\n+  if (!gameState.player) {\\n+    return false;\\n+  }\\n+  const weapon = gameState.player.manualWeapons.GodsayerSword;\\n+  if (!weapon) {\\n+    return false;\\n+  }\\n+  return weapon.trigger(gameState.player, gameState.enemies);\\n+}\\n+\\n+function gameLoop(dt) {\\n+  ensureCanvas();\\n+  if (!gameState.ctx) {\\n+    return;\\n+  }\\n+  if (gameState.player && gameState.alive) {\\n+    gameState.gameTime += dt;\\n+    gameState.waveTimer += dt;\\n+    gameState.bossTimer += dt;\\n+    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\\n+    gameState.player.update(dt, gameState);\\n+    updateEnemies(dt);\\n+    updateProjectiles(dt);\\n+    updateSouls(dt);\\n+    updateParticles(dt);\\n+    if (gameState.waveTimer >= 30) {\\n+      spawnWave();\\n+    }\\n+    if (gameState.bossTimer >= 120) {\\n+      spawnBoss();\\n+    }\\n+    if (gameState.player.health <= 0) {\\n+      gameState.alive = false;\\n+    }\\n+  }\\n+  drawGame();\\n+  notifyHUD();\\n+}\\n+\\n+function drawGame() {\\n+  const ctx = gameState.ctx;\\n+  if (!ctx) {\\n+    return;\\n+  }\\n+  ctx.save();\\n+  if (gameState.screenShake > 0) {\\n+    ctx.translate(\\n+      (Math.random() - 0.5) * gameState.screenShake,\\n+      (Math.random() - 0.5) * gameState.screenShake\\n+    );\\n+    gameState.screenShake *= 0.9;\\n+  }\\n+  drawBackground(ctx);\\n+  gameState.souls.forEach((soul) => soul.draw(ctx));\\n+  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\\n+  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\\n+  if (gameState.player) {\\n+    gameState.player.draw(ctx);\\n+  }\\n+  gameState.particles.forEach((particle) => particle.draw(ctx));\\n+  drawHUDOverlay(ctx);\\n+  ctx.restore();\\n+}\\n+\\n+function drawBackground(ctx) {\\n+  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\\n+  gradient.addColorStop(0, '#1a0327');\\n+  gradient.addColorStop(0.5, '#1f1f49');\\n+  gradient.addColorStop(1, '#040308');\\n+  ctx.fillStyle = gradient;\\n+  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\\n+  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\\n+  for (let i = 0; i < 8; i += 1) {\\n+    const angle = (Math.PI * 2 * i) / 8;\\n+    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\\n+    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\\n+    ctx.beginPath();\\n+    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\\n+    ctx.stroke();\\n+  }\\n+  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\\n+  ctx.beginPath();\\n+  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\\n+  ctx.stroke();\\n+}\\n+\\n+function drawHUDOverlay(ctx) {\\n+  if (!gameState.player) {\\n+    return;\\n+  }\\n+  ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n+  ctx.fillRect(15, 15, 220, 110);\\n+  ctx.fillStyle = '#ffffff';\\n+  ctx.font = '14px \\\"Segoe UI\\\", sans-serif';\\n+  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\\n+  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\\n+  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\\n+  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\\n+  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\\n+  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\\n+}\\n+\\n+function notifyHUD() {\\n+  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\\n+    window.updateHUD(gameState);\\n+  }\\n+  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\\n+    window.showDeathScreen(gameState);\\n+  }\\n+}\\n+\\n+function animationLoop(timestamp) {\\n+  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\\n+  gameState.lastTimestamp = timestamp;\\n+  gameLoop(dt || TARGET_DELTA);\\n+  window.requestAnimationFrame(animationLoop);\\n+}\\n+\\n+window.requestAnimationFrame(animationLoop);\\n+\\n+function setKeyState(key, isDown) {\\n+  if (gameState.keys[key] !== undefined) {\\n+    gameState.keys[key] = isDown;\\n+  }\\n+}\\n+\\n+window.initGame = initGame;\\n+window.triggerGodsayerSword = triggerGodsayerSword;\\n+window.setKeyState = setKeyState;\\n+window.gameState = gameState;\\n+window.spawnWave = spawnWave;\\n+window.spawnBoss = spawnBoss;\\n+window.grantEssence = grantEssence;\\n+window.handleEnemyDeath = handleEnemyDeath;\\n+window.triggerScreenShake = triggerScreenShake;\\n\\n```\\nold_file_revision_id:82ec2a0b-979a-4453-92ed-863a4df5d463\\nnew_file_revision_id:618432e4-6887-439f-8fe9-e93e229b5b13\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "content_length": 38536, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -0,0 +1,1236 @@\\n+class Vector2 {\\n+  constructor(x = 0, y = 0) {\\n+    this.x = x;\\n+    this.y = y;\\n+  }\\n+\\n+  clone() {\\n+    return new Vector2(this.x, this.y);\\n+  }\\n+\\n+  add(v) {\\n+    this.x += v.x;\\n+    this.y += v.y;\\n+    return this;\\n+  }\\n+\\n+  subtract(v) {\\n+    this.x -= v.x;\\n+    this.y -= v.y;\\n+    return this;\\n+  }\\n+\\n+  scale(s) {\\n+    this.x *= s;\\n+    this.y *= s;\\n+    return this;\\n+  }\\n+\\n+  length() {\\n+    return Math.sqrt(this.x * this.x + this.y * this.y);\\n+  }\\n+\\n+  normalize() {\\n+    const len = this.length() || 1;\\n+    this.x /= len;\\n+    this.y /= len;\\n+    return this;\\n+  }\\n+\\n+  distance(other) {\\n+    const dx = this.x - other.x;\\n+    const dy = this.y - other.y;\\n+    return Math.sqrt(dx * dx + dy * dy);\\n+  }\\n+\\n+  angle(other) {\\n+    return Math.atan2(other.y - this.y, other.x - this.x);\\n+  }\\n+\\n+  static fromAngle(angle, magnitude = 1) {\\n+    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\\n+  }\\n+}\\n+\\n+const CANVAS_WIDTH = 1000;\\n+const CANVAS_HEIGHT = 600;\\n+const TARGET_DELTA = 1 / 60;\\n+const DEG_TO_RAD = Math.PI / 180;\\n+const DEFAULT_ANIMATION = {\\n+  animations: {\\n+    idle: { frameCount: 1, frameTime: 1, loop: true },\\n+    run: { frameCount: 1, frameTime: 1, loop: true },\\n+    attack: { frameCount: 1, frameTime: 1, loop: false },\\n+    hit: { frameCount: 1, frameTime: 1, loop: false },\\n+    death: { frameCount: 1, frameTime: 1, loop: false }\\n+  }\\n+};\\n+\\n+const CHARACTER_DEFS = {\\n+  knight: {\\n+    maxHealth: 100,\\n+    baseDamage: 12,\\n+    range: 110,\\n+    speed: 200,\\n+    armor: 5,\\n+    spriteSize: 48\\n+  },\\n+  witch: {\\n+    maxHealth: 70,\\n+    baseDamage: 8,\\n+    range: 140,\\n+    speed: 180,\\n+    armor: 2,\\n+    spriteSize: 48\\n+  },\\n+  rogue: {\\n+    maxHealth: 85,\\n+    baseDamage: 10,\\n+    range: 90,\\n+    speed: 250,\\n+    armor: 3,\\n+    spriteSize: 48,\\n+    dodgeChance: 0.1\\n+  }\\n+};\\n+\\n+const ENEMY_DEFS = {\\n+  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\\n+  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\\n+  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\\n+  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\\n+  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\\n+  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\\n+  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\\n+};\\n+\\n+const BOSS_DEFS = {\\n+  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\\n+  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\\n+  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\\n+};\\n+\\n+const SOUL_TYPES = {\\n+  ethereal: { xp: 10, color: '#f3f6ff' },\\n+  essence: { xp: 0, color: '#ffd95a', essence: 1 },\\n+  corrupted: { xp: 20, color: '#b21f35' },\\n+  cursed: { xp: 50, color: '#0d0d0d' }\\n+};\\n+\\n+const LEVEL_WEAPON_UNLOCK = [\\n+  'ShatterburstAxe',\\n+  'SoulreaverDagger',\\n+  'EternalHalberd',\\n+  'ChaosOrb',\\n+  'ReapersScythe',\\n+  'BloodmoonLance',\\n+  'VoidSummoner'\\n+];\\n+\\n+const spriteCache = {};\\n+const animationCache = {};\\n+\\n+function getAnimationPath(name) {\\n+  return `animations/${name}.json`;\\n+}\\n+\\n+function getSprite(name, spriteSize = 48) {\\n+  if (spriteCache[name]) {\\n+    return spriteCache[name];\\n+  }\\n+  const sprite = new Sprite(\\n+    name,\\n+    `sprites/${name}.png`,\\n+    spriteSize,\\n+    spriteSize,\\n+    getAnimationPath(name)\\n+  );\\n+  spriteCache[name] = sprite;\\n+  return sprite;\\n+}\\n+\\n+function loadAnimationData(name) {\\n+  if (animationCache[name]) {\\n+    return animationCache[name];\\n+  }\\n+  animationCache[name] = DEFAULT_ANIMATION;\\n+  fetch(getAnimationPath(name))\\n+    .then((resp) => resp.json())\\n+    .then((data) => {\\n+      animationCache[name] = data.animations ? data : { animations: data };\\n+    })\\n+    .catch(() => {\\n+      animationCache[name] = DEFAULT_ANIMATION;\\n+    });\\n+  return animationCache[name];\\n+}\\n+\\n+class Sprite {\\n+  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\\n+    this.name = name;\\n+    this.image = new Image();\\n+    this.image.src = imageUrl;\\n+    this.imageLoaded = false;\\n+    this.imageFailed = false;\\n+    this.image.onload = () => {\\n+      this.imageLoaded = true;\\n+    };\\n+    this.image.onerror = () => {\\n+      this.imageFailed = true;\\n+    };\\n+    this.frameWidth = frameWidth;\\n+    this.frameHeight = frameHeight;\\n+    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\\n+    this.currentState = 'idle';\\n+    this.animationTime = 0;\\n+    this.frameIndex = 0;\\n+    this.colorFallback = '#ffffff';\\n+    this.animationPath = animationPath;\\n+    this.refreshAnimation();\\n+  }\\n+\\n+  refreshAnimation() {\\n+    fetch(this.animationPath)\\n+      .then((resp) => resp.json())\\n+      .then((data) => {\\n+        this.animationData = data.animations ? data : { animations: data };\\n+      })\\n+      .catch(() => {\\n+        this.animationData = DEFAULT_ANIMATION;\\n+      });\\n+  }\\n+\\n+  update(dt, desiredState = 'idle') {\\n+    if (this.currentState !== desiredState) {\\n+      this.currentState = desiredState;\\n+      this.animationTime = 0;\\n+    } else {\\n+      this.animationTime += dt;\\n+    }\\n+    const animSpec = this.getAnimationSpec(this.currentState);\\n+    const totalDuration = animSpec.frameCount * animSpec.frameTime;\\n+    if (animSpec.loop) {\\n+      this.animationTime = this.animationTime % (totalDuration || 1);\\n+    } else if (this.animationTime > totalDuration) {\\n+      this.animationTime = totalDuration - animSpec.frameTime;\\n+    }\\n+    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\\n+  }\\n+\\n+  getAnimationSpec(state) {\\n+    const data = this.animationData.animations || this.animationData;\\n+    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\\n+  }\\n+\\n+  draw(ctx, x, y, scale = 1, flipX = false) {\\n+    if (this.imageLoaded && !this.imageFailed) {\\n+      const animSpec = this.getAnimationSpec(this.currentState);\\n+      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\\n+      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\\n+      const srcY = 0;\\n+      const destWidth = this.frameWidth * scale;\\n+      const destHeight = this.frameHeight * scale;\\n+      ctx.save();\\n+      if (flipX) {\\n+        ctx.translate(x + destWidth, y);\\n+        ctx.scale(-1, 1);\\n+        ctx.drawImage(\\n+          this.image,\\n+          srcX,\\n+          srcY,\\n+          this.frameWidth,\\n+          this.frameHeight,\\n+          0,\\n+          0,\\n+          destWidth,\\n+          destHeight\\n+        );\\n+      } else {\\n+        ctx.drawImage(\\n+          this.image,\\n+          srcX,\\n+          srcY,\\n+          this.frameWidth,\\n+          this.frameHeight,\\n+          x,\\n+          y,\\n+          destWidth,\\n+          destHeight\\n+        );\\n+      }\\n+      ctx.restore();\\n+    } else {\\n+      ctx.fillStyle = this.colorFallback;\\n+      ctx.beginPath();\\n+      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    }\\n+  }\\n+}\\n+\\n+class Particle {\\n+  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\\n+    this.position = new Vector2(x, y);\\n+    this.velocity = new Vector2(vx, vy);\\n+    this.lifetime = lifetime;\\n+    this.remaining = lifetime;\\n+    this.color = color;\\n+    this.type = type;\\n+    this.size = type === 'explosion' ? 10 : 4;\\n+  }\\n+\\n+  update(dt) {\\n+    this.remaining -= dt;\\n+    if (this.type === 'blood' || this.type === 'spark') {\\n+      this.velocity.y += 30 * dt;\\n+    }\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+  }\\n+\\n+  draw(ctx) {\\n+    if (this.remaining <= 0) {\\n+      return;\\n+    }\\n+    const alpha = Math.max(this.remaining / this.lifetime, 0);\\n+    ctx.save();\\n+    ctx.globalAlpha = alpha;\\n+    if (this.type === 'glow') {\\n+      const gradient = ctx.createRadialGradient(\\n+        this.position.x,\\n+        this.position.y,\\n+        0,\\n+        this.position.x,\\n+        this.position.y,\\n+        this.size * 2\\n+      );\\n+      gradient.addColorStop(0, this.color);\\n+      gradient.addColorStop(1, 'transparent');\\n+      ctx.fillStyle = gradient;\\n+      ctx.beginPath();\\n+      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    } else {\\n+      ctx.fillStyle = this.color;\\n+      ctx.beginPath();\\n+      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\\n+      ctx.fill();\\n+    }\\n+    ctx.restore();\\n+  }\\n+}\\n+\\n+class Projectile {\\n+  constructor(config) {\\n+    this.position = config.position.clone();\\n+    this.velocity = config.velocity.clone();\\n+    this.damage = config.damage;\\n+    this.range = config.range;\\n+    this.traveled = 0;\\n+    this.radius = config.radius || 6;\\n+    this.pierce = config.pierce || 1;\\n+    this.owner = config.owner;\\n+    this.lifesteal = config.lifesteal || 0;\\n+    this.color = config.color || '#ffffff';\\n+  }\\n+\\n+  update(dt) {\\n+    const movement = this.velocity.clone().scale(dt);\\n+    this.position.add(movement);\\n+    this.traveled += movement.length();\\n+  }\\n+\\n+  isExpired() {\\n+    return this.traveled >= this.range;\\n+  }\\n+\\n+  draw(ctx) {\\n+    ctx.fillStyle = this.color;\\n+    ctx.beginPath();\\n+    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\\n+    ctx.fill();\\n+  }\\n+}\\n+\\n+class Soul {\\n+  constructor(x, y, type) {\\n+    this.position = new Vector2(x, y);\\n+    this.type = type;\\n+    this.radius = 8;\\n+    this.floatTimer = 0;\\n+    this.collected = false;\\n+  }\\n+\\n+  update(dt, player) {\\n+    this.floatTimer += dt;\\n+    const bob = Math.sin(this.floatTimer * 3) * 2;\\n+    if (player && player.position.distance(this.position) < 25) {\\n+      this.collected = true;\\n+      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\\n+      if (SOUL_TYPES[this.type].essence) {\\n+        grantEssence(SOUL_TYPES[this.type].essence);\\n+      }\\n+    }\\n+    this.renderOffset = bob;\\n+  }\\n+\\n+  draw(ctx) {\\n+    ctx.fillStyle = SOUL_TYPES[this.type].color;\\n+    ctx.beginPath();\\n+    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\\n+    ctx.fill();\\n+  }\\n+}\\n+\\n+class Weapon {\\n+  constructor(name, config) {\\n+    this.name = name;\\n+    this.damage = config.damage;\\n+    this.fireRate = config.fireRate || 1;\\n+    this.range = config.range || 100;\\n+    this.type = config.type;\\n+    this.cost = config.cost || 0;\\n+    this.manual = config.manual || false;\\n+    this.cooldown = 0;\\n+    this.execute = config.execute;\\n+    this.lifesteal = config.lifesteal || 0;\\n+    this.extra = config.extra || {};\\n+  }\\n+\\n+  update(dt, player, enemies) {\\n+    if (this.manual) {\\n+      return;\\n+    }\\n+    this.cooldown -= dt;\\n+    if (this.cooldown <= 0) {\\n+      const fired = this.execute(player, enemies, this);\\n+      if (fired) {\\n+        this.cooldown = 1 / this.fireRate;\\n+      }\\n+    }\\n+  }\\n+\\n+  trigger(player, enemies) {\\n+    return this.execute(player, enemies, this);\\n+  }\\n+}\\n+\\n+class Enemy {\\n+  constructor(type, x, y, isBoss = false) {\\n+    this.type = type;\\n+    this.isBoss = isBoss;\\n+    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\\n+    this.maxHealth = this.definition.health;\\n+    this.health = this.maxHealth;\\n+    this.damage = this.definition.damage;\\n+    this.speed = this.definition.speed;\\n+    this.position = new Vector2(x, y);\\n+    this.velocity = new Vector2();\\n+    this.alive = true;\\n+    this.state = 'idle';\\n+    this.deathTimer = 0;\\n+    this.sprite = getSprite(type, this.definition.spriteSize || 48);\\n+    this.sprite.colorFallback = this.definition.color;\\n+  }\\n+\\n+  update(dt, player, multiplier) {\\n+    if (!this.alive) {\\n+      this.deathTimer += dt;\\n+      this.sprite.update(dt, 'death');\\n+      return;\\n+    }\\n+    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\\n+    const distance = Math.max(toPlayer.length(), 0.0001);\\n+    const direction = toPlayer.clone().scale(1 / distance);\\n+    const effectiveSpeed = this.speed * multiplier;\\n+    if (this.type === 'wraith') {\\n+      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\\n+      direction.add(swirl).normalize();\\n+    }\\n+    this.velocity = direction.clone().scale(effectiveSpeed);\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\\n+  }\\n+\\n+  takeDamage(amount) {\\n+    if (!this.alive) {\\n+      return false;\\n+    }\\n+    this.health -= amount;\\n+    if (this.health <= 0) {\\n+      this.alive = false;\\n+      this.state = 'death';\\n+      return true;\\n+    }\\n+    this.state = 'hit';\\n+    return false;\\n+  }\\n+\\n+  draw(ctx) {\\n+    const size = this.definition.spriteSize || 48;\\n+    const drawX = this.position.x - size * 0.5;\\n+    const drawY = this.position.y - size * 0.5;\\n+    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\\n+    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\\n+    if (this.alive) {\\n+      ctx.fillStyle = '#222';\\n+      ctx.fillRect(drawX, drawY - 10, size, 4);\\n+      ctx.fillStyle = '#e63946';\\n+      const hpRatio = Math.max(this.health / this.maxHealth, 0);\\n+      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\\n+    }\\n+  }\\n+}\\n+\\n+class Player {\\n+  constructor(character) {\\n+    const def = CHARACTER_DEFS[character];\\n+    this.character = character;\\n+    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\\n+    this.velocity = new Vector2();\\n+    this.speed = def.speed;\\n+    this.range = def.range;\\n+    this.maxHealth = def.maxHealth;\\n+    this.health = def.maxHealth;\\n+    this.baseDamage = def.baseDamage;\\n+    this.level = 1;\\n+    this.experience = 0;\\n+    this.nextLevelExp = 100;\\n+    this.armor = def.armor || 0;\\n+    this.sprite = getSprite(character, def.spriteSize);\\n+    this.sprite.colorFallback = '#f5f3f4';\\n+    this.state = 'idle';\\n+    this.killStreak = 0;\\n+    this.killStreakTimer = 0;\\n+    this.killStreakActive = false;\\n+    this.killStreakDuration = 5;\\n+    this.weapons = [];\\n+    this.manualWeapons = {};\\n+    this.unlockWeapon('CursedBlade');\\n+    this.unlockWeapon('GodsayerSword');\\n+    this.unlockWeapon('ShatterburstAxe');\\n+    this.unlockWeapon('SoulreaverDagger');\\n+    this.unlockWeapon('EternalHalberd');\\n+    this.unlockWeapon('ChaosOrb');\\n+    this.unlockWeapon('ReapersScythe');\\n+    this.unlockWeapon('BloodmoonLance');\\n+    this.unlockWeapon('VoidSummoner');\\n+    this.weapons = this.weapons.filter((w) => !w.manual);\\n+    this.sprite.refreshAnimation();\\n+  }\\n+\\n+  unlockWeapon(name) {\\n+    if (!WEAPON_CONFIGS[name]) {\\n+      return;\\n+    }\\n+    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\\n+    if (weapon.manual) {\\n+      this.manualWeapons[name] = weapon;\\n+    } else {\\n+      this.weapons.push(weapon);\\n+    }\\n+  }\\n+\\n+  update(dt, state) {\\n+    const keys = state.keys;\\n+    const input = new Vector2(\\n+      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\\n+      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\\n+    );\\n+    if (input.length() > 0) {\\n+      input.normalize();\\n+      this.velocity = input.clone().scale(this.speed);\\n+      this.state = 'run';\\n+    } else {\\n+      this.velocity = new Vector2();\\n+      this.state = 'idle';\\n+    }\\n+    this.position.add(this.velocity.clone().scale(dt));\\n+    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\\n+    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\\n+    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\\n+    if (this.killStreakActive) {\\n+      this.killStreakTimer -= dt;\\n+      if (this.killStreakTimer <= 0) {\\n+        this.killStreakActive = false;\\n+        this.killStreak = 0;\\n+      }\\n+    }\\n+    this.sprite.update(dt, this.state);\\n+  }\\n+\\n+  takeDamage(amount) {\\n+    if (this.character === 'rogue' && Math.random() < 0.1) {\\n+      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\\n+      return;\\n+    }\\n+    const mitigated = Math.max(amount - this.armor, 1);\\n+    this.health -= mitigated;\\n+    if (this.health <= 0) {\\n+      this.health = 0;\\n+      gameState.alive = false;\\n+    }\\n+  }\\n+\\n+  gainExperience(amount) {\\n+    this.experience += amount;\\n+    while (this.experience >= this.nextLevelExp) {\\n+      this.experience -= this.nextLevelExp;\\n+      this.level += 1;\\n+      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\\n+      this.maxHealth += 5;\\n+      this.health = this.maxHealth;\\n+      if (this.character === 'knight') {\\n+        this.armor += 1;\\n+      }\\n+      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\\n+        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\\n+        if (weaponName) {\\n+          this.unlockWeapon(weaponName);\\n+        }\\n+      }\\n+    }\\n+  }\\n+\\n+  registerKill() {\\n+    this.killStreak += 1;\\n+    if (this.character === 'rogue' && this.killStreak >= 5) {\\n+      this.killStreakActive = true;\\n+      this.killStreakTimer = this.killStreakDuration;\\n+    }\\n+  }\\n+\\n+  getDamageMultiplier() {\\n+    let multiplier = 1 + (this.level - 1) * 0.05;\\n+    if (this.killStreakActive) {\\n+      multiplier += 0.15;\\n+    }\\n+    return multiplier;\\n+  }\\n+\\n+  draw(ctx) {\\n+    const size = CHARACTER_DEFS[this.character].spriteSize;\\n+    const drawX = this.position.x - size * 0.5;\\n+    const drawY = this.position.y - size * 0.5;\\n+    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\\n+    ctx.fillStyle = '#222';\\n+    ctx.fillRect(drawX, drawY - 12, size, 5);\\n+    ctx.fillStyle = '#7cf5ff';\\n+    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\\n+  }\\n+}\\n+\\n+const WEAPON_CONFIGS = {\\n+  CursedBlade: {\\n+    damage: 10,\\n+    fireRate: 1,\\n+    range: 100,\\n+    type: 'cone',\\n+    execute: (player, enemies, weapon) => {\\n+      let hit = false;\\n+      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) {\\n+          return;\\n+        }\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const angleToEnemy = Math.atan2(\\n+            enemy.position.y - player.position.y,\\n+            enemy.position.x - player.position.x\\n+          );\\n+          let delta = angleToEnemy - facingAngle;\\n+          while (delta > Math.PI) delta -= Math.PI * 2;\\n+          while (delta < -Math.PI) delta += Math.PI * 2;\\n+          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            hit = hit || killed;\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+          }\\n+        }\\n+      });\\n+      if (hit) {\\n+        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\\n+      }\\n+      return true;\\n+    }\\n+  },\\n+  ShatterburstAxe: {\\n+    damage: 15,\\n+    fireRate: 0.8,\\n+    range: 60,\\n+    type: 'aoe',\\n+    execute: (player, enemies, weapon) => {\\n+      let any = false;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        if (player.position.distance(enemy.position) <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          any = any || killed;\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          } else {\\n+            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\\n+            enemy.position.add(push);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\\n+      return true;\\n+    }\\n+  },\\n+  SoulreaverDagger: {\\n+    damage: 5,\\n+    fireRate: 2,\\n+    range: 30,\\n+    type: 'multi-hit',\\n+    execute: (player, enemies, weapon) => {\\n+      let target = null;\\n+      let closest = Infinity;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance < closest && distance <= weapon.range) {\\n+          closest = distance;\\n+          target = enemy;\\n+        }\\n+      });\\n+      if (!target) {\\n+        return false;\\n+      }\\n+      for (let i = 0; i < 3; i += 1) {\\n+        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+        if (killed) {\\n+          handleEnemyDeath(target);\\n+          break;\\n+        }\\n+        player.health = Math.min(\\n+          player.maxHealth,\\n+          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\\n+        );\\n+      }\\n+      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\\n+      return true;\\n+    }\\n+  },\\n+  EternalHalberd: {\\n+    damage: 25,\\n+    fireRate: 0.5,\\n+    range: 80,\\n+    type: 'aoe',\\n+    execute: (player, enemies, weapon) => {\\n+      let hitAny = false;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          hitAny = hitAny || killed;\\n+          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\\n+          enemy.position.add(pull.scale(0.1));\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\\n+      return true;\\n+    }\\n+  },\\n+  ChaosOrb: {\\n+    damage: 8,\\n+    fireRate: 1.2,\\n+    range: 300,\\n+    type: 'projectile',\\n+    execute: (player) => {\\n+      const orbCount = 2 + Math.floor(Math.random() * 3);\\n+      for (let i = 0; i < orbCount; i += 1) {\\n+        const angle = Math.random() * Math.PI * 2;\\n+        const velocity = Vector2.fromAngle(angle, 200);\\n+        gameState.projectiles.push(\\n+          new Projectile({\\n+            position: player.position.clone(),\\n+            velocity,\\n+            damage: 8 * player.getDamageMultiplier(),\\n+            range: 320,\\n+            pierce: 3,\\n+            owner: player,\\n+            color: '#7bed9f'\\n+          })\\n+        );\\n+      }\\n+      return true;\\n+    }\\n+  },\\n+  ReapersScythe: {\\n+    damage: 20,\\n+    fireRate: 0.8,\\n+    range: 100,\\n+    type: 'spin',\\n+    execute: (player, enemies, weapon) => {\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const distance = player.position.distance(enemy.position);\\n+        if (distance <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          } else {\\n+            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\\n+            enemy.position.add(pull);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\\n+      return true;\\n+    }\\n+  },\\n+  BloodmoonLance: {\\n+    damage: 20,\\n+    fireRate: 1,\\n+    range: 400,\\n+    type: 'beam',\\n+    lifesteal: 0.5,\\n+    execute: (player, enemies, weapon) => {\\n+      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        const toEnemy = enemy.position.clone().subtract(player.position);\\n+        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\\n+        if (projection >= 0 && projection <= weapon.range) {\\n+          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\\n+          if (perpendicular <= 40) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+            player.health = Math.min(\\n+              player.maxHealth,\\n+              player.health + weapon.damage * weapon.lifesteal\\n+            );\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(\\n+        player.position.x + direction.x * 60,\\n+        player.position.y + direction.y * 60,\\n+        '#ff99c8',\\n+        'glow',\\n+        14\\n+      );\\n+      return true;\\n+    }\\n+  },\\n+  GodsayerSword: {\\n+    damage: 100,\\n+    fireRate: 1,\\n+    range: 150,\\n+    type: 'manual',\\n+    manual: true,\\n+    cost: 1,\\n+    execute: (player, enemies, weapon) => {\\n+      if (gameState.weaponCharges < weapon.cost) {\\n+        return false;\\n+      }\\n+      gameState.weaponCharges -= weapon.cost;\\n+      enemies.forEach((enemy) => {\\n+        if (!enemy.alive) return;\\n+        if (player.position.distance(enemy.position) <= weapon.range) {\\n+          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+          if (killed) {\\n+            handleEnemyDeath(enemy);\\n+          }\\n+        }\\n+      });\\n+      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\\n+      triggerScreenShake();\\n+      return true;\\n+    }\\n+  },\\n+  VoidSummoner: {\\n+    damage: 15,\\n+    fireRate: 0.125,\\n+    range: 200,\\n+    cost: 2,\\n+    type: 'summon',\\n+    execute: (player, enemies, weapon) => {\\n+      if (gameState.weaponCharges < weapon.cost) {\\n+        return false;\\n+      }\\n+      gameState.weaponCharges -= weapon.cost;\\n+      for (let i = 0; i < 3; i += 1) {\\n+        const angle = (Math.PI * 2 * i) / 3;\\n+        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\\n+        enemies.forEach((enemy) => {\\n+          if (!enemy.alive) return;\\n+          if (summonPos.distance(enemy.position) <= 70) {\\n+            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n+            if (killed) {\\n+              handleEnemyDeath(enemy);\\n+            }\\n+          }\\n+        });\\n+        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\\n+      }\\n+      return true;\\n+    }\\n+  }\\n+};\\n+\\n+const gameState = {\\n+  canvas: null,\\n+  ctx: null,\\n+  player: null,\\n+  enemies: [],\\n+  souls: [],\\n+  particles: [],\\n+  projectiles: [],\\n+  alive: false,\\n+  keys: { w: false, a: false, s: false, d: false },\\n+  gameTime: 0,\\n+  waveTimer: 0,\\n+  waveNumber: 0,\\n+  bossTimer: 0,\\n+  bossIndex: 0,\\n+  enemiesKilled: 0,\\n+  difficultyMultiplier: 1,\\n+  weaponCharges: 0,\\n+  essenceCollected: 0,\\n+  pendingGodsayer: false,\\n+  screenShake: 0,\\n+  lastTimestamp: performance.now()\\n+};\\n+\\n+function ensureCanvas() {\\n+  if (!gameState.canvas) {\\n+    gameState.canvas = document.getElementById('gameCanvas');\\n+    if (gameState.canvas) {\\n+      gameState.ctx = gameState.canvas.getContext('2d');\\n+    }\\n+  }\\n+}\\n+\\n+function initGame(character = 'knight') {\\n+  ensureCanvas();\\n+  gameState.player = new Player(character);\\n+  gameState.enemies = [];\\n+  gameState.souls = [];\\n+  gameState.particles = [];\\n+  gameState.projectiles = [];\\n+  gameState.gameTime = 0;\\n+  gameState.waveTimer = 0;\\n+  gameState.waveNumber = 0;\\n+  gameState.bossTimer = 0;\\n+  gameState.enemiesKilled = 0;\\n+  gameState.weaponCharges = 0;\\n+  gameState.essenceCollected = 0;\\n+  gameState.alive = true;\\n+  gameState.screenShake = 0;\\n+}\\n+\\n+function spawnWave() {\\n+  if (!gameState.player) {\\n+    return;\\n+  }\\n+  const count = 5 + gameState.waveNumber * 2;\\n+  for (let i = 0; i < count; i += 1) {\\n+    const isElite = Math.random() < 0.2;\\n+    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\\n+    const type = pool[Math.floor(Math.random() * pool.length)];\\n+    const angle = Math.random() * Math.PI * 2;\\n+    const spawnRadius = 150 + Math.random() * 100;\\n+    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\\n+    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\\n+    gameState.enemies.push(new Enemy(type, posX, posY));\\n+  }\\n+  gameState.waveNumber += 1;\\n+  gameState.waveTimer = 0;\\n+}\\n+\\n+function spawnBoss() {\\n+  const bossKeys = Object.keys(BOSS_DEFS);\\n+  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\\n+  gameState.bossIndex += 1;\\n+  const edge = Math.floor(Math.random() * 4);\\n+  let x = 0;\\n+  let y = 0;\\n+  if (edge === 0) {\\n+    x = Math.random() * CANVAS_WIDTH;\\n+    y = -50;\\n+  } else if (edge === 1) {\\n+    x = CANVAS_WIDTH + 50;\\n+    y = Math.random() * CANVAS_HEIGHT;\\n+  } else if (edge === 2) {\\n+    x = Math.random() * CANVAS_WIDTH;\\n+    y = CANVAS_HEIGHT + 50;\\n+  } else {\\n+    x = -50;\\n+    y = Math.random() * CANVAS_HEIGHT;\\n+  }\\n+  const boss = new Enemy(bossName, x, y, true);\\n+  gameState.enemies.push(boss);\\n+  gameState.bossTimer = 0;\\n+  triggerScreenShake(20);\\n+}\\n+\\n+function grantEssence(amount) {\\n+  gameState.essenceCollected += amount;\\n+  if (gameState.essenceCollected >= 5) {\\n+    const charges = Math.floor(gameState.essenceCollected / 5);\\n+    gameState.weaponCharges += charges;\\n+    gameState.essenceCollected -= charges * 5;\\n+  }\\n+}\\n+\\n+function handleEnemyDeath(enemy) {\\n+  if (!enemy) {\\n+    return;\\n+  }\\n+  gameState.enemiesKilled += 1;\\n+  if (gameState.player) {\\n+    gameState.player.registerKill();\\n+  }\\n+  dropSoul(enemy);\\n+  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\\n+}\\n+\\n+function dropSoul(enemy) {\\n+  if (enemy.isBoss) {\\n+    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\\n+    return;\\n+  }\\n+  if (ENEMY_DEFS[enemy.type].elite) {\\n+    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\\n+    if (Math.random() < 0.4) {\\n+      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\\n+    }\\n+  } else {\\n+    if (Math.random() < 0.95) {\\n+      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\\n+    }\\n+    if (Math.random() < 0.05) {\\n+      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\\n+    }\\n+  }\\n+}\\n+\\n+function spawnParticleBurst(x, y, color, type, count) {\\n+  for (let i = 0; i < count; i += 1) {\\n+    const angle = Math.random() * Math.PI * 2;\\n+    const speed = 40 + Math.random() * 120;\\n+    const vx = Math.cos(angle) * speed;\\n+    const vy = Math.sin(angle) * speed;\\n+    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\\n+    gameState.particles.push(particle);\\n+  }\\n+}\\n+\\n+function triggerScreenShake(intensity = 10) {\\n+  gameState.screenShake = Math.max(gameState.screenShake, intensity);\\n+}\\n+\\n+function updateProjectiles(dt) {\\n+  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\\n+    const projectile = gameState.projectiles[i];\\n+    projectile.update(dt);\\n+    let removed = false;\\n+    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\\n+      const enemy = gameState.enemies[j];\\n+      if (!enemy.alive) continue;\\n+      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\\n+        const killed = enemy.takeDamage(projectile.damage);\\n+        if (killed) {\\n+          handleEnemyDeath(enemy);\\n+        }\\n+        projectile.pierce -= 1;\\n+        if (projectile.lifesteal && gameState.player) {\\n+          gameState.player.health = Math.min(\\n+            gameState.player.maxHealth,\\n+            gameState.player.health + projectile.damage * projectile.lifesteal\\n+          );\\n+        }\\n+        if (projectile.pierce <= 0) {\\n+          removed = true;\\n+          break;\\n+        }\\n+      }\\n+    }\\n+    if (projectile.isExpired() || removed) {\\n+      gameState.projectiles.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateSouls(dt) {\\n+  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\\n+    const soul = gameState.souls[i];\\n+    soul.update(dt, gameState.player);\\n+    if (soul.collected) {\\n+      gameState.souls.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateParticles(dt) {\\n+  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\\n+    const particle = gameState.particles[i];\\n+    particle.update(dt);\\n+    if (particle.remaining <= 0) {\\n+      gameState.particles.splice(i, 1);\\n+    }\\n+  }\\n+}\\n+\\n+function updateEnemies(dt) {\\n+  const player = gameState.player;\\n+  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\\n+    const enemy = gameState.enemies[i];\\n+    enemy.update(dt, player, gameState.difficultyMultiplier);\\n+    if (!enemy.alive && enemy.deathTimer > 1.5) {\\n+      gameState.enemies.splice(i, 1);\\n+    }\\n+    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\\n+      const damage = enemy.damage;\\n+      player.takeDamage(damage);\\n+      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\\n+    }\\n+  }\\n+}\\n+\\n+function triggerGodsayerSword() {\\n+  if (!gameState.player) {\\n+    return false;\\n+  }\\n+  const weapon = gameState.player.manualWeapons.GodsayerSword;\\n+  if (!weapon) {\\n+    return false;\\n+  }\\n+  return weapon.trigger(gameState.player, gameState.enemies);\\n+}\\n+\\n+function gameLoop(dt) {\\n+  ensureCanvas();\\n+  if (!gameState.ctx) {\\n+    return;\\n+  }\\n+  if (gameState.player && gameState.alive) {\\n+    gameState.gameTime += dt;\\n+    gameState.waveTimer += dt;\\n+    gameState.bossTimer += dt;\\n+    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\\n+    gameState.player.update(dt, gameState);\\n+    updateEnemies(dt);\\n+    updateProjectiles(dt);\\n+    updateSouls(dt);\\n+    updateParticles(dt);\\n+    if (gameState.waveTimer >= 30) {\\n+      spawnWave();\\n+    }\\n+    if (gameState.bossTimer >= 120) {\\n+      spawnBoss();\\n+    }\\n+    if (gameState.player.health <= 0) {\\n+      gameState.alive = false;\\n+    }\\n+  }\\n+  drawGame();\\n+  notifyHUD();\\n+}\\n+\\n+function drawGame() {\\n+  const ctx = gameState.ctx;\\n+  if (!ctx) {\\n+    return;\\n+  }\\n+  ctx.save();\\n+  if (gameState.screenShake > 0) {\\n+    ctx.translate(\\n+      (Math.random() - 0.5) * gameState.screenShake,\\n+      (Math.random() - 0.5) * gameState.screenShake\\n+    );\\n+    gameState.screenShake *= 0.9;\\n+  }\\n+  drawBackground(ctx);\\n+  gameState.souls.forEach((soul) => soul.draw(ctx));\\n+  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\\n+  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\\n+  if (gameState.player) {\\n+    gameState.player.draw(ctx);\\n+  }\\n+  gameState.particles.forEach((particle) => particle.draw(ctx));\\n+  drawHUDOverlay(ctx);\\n+  ctx.restore();\\n+}\\n+\\n+function drawBackground(ctx) {\\n+  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\\n+  gradient.addColorStop(0, '#1a0327');\\n+  gradient.addColorStop(0.5, '#1f1f49');\\n+  gradient.addColorStop(1, '#040308');\\n+  ctx.fillStyle = gradient;\\n+  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\\n+  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\\n+  for (let i = 0; i < 8; i += 1) {\\n+    const angle = (Math.PI * 2 * i) / 8;\\n+    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\\n+    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\\n+    ctx.beginPath();\\n+    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\\n+    ctx.stroke();\\n+  }\\n+  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\\n+  ctx.beginPath();\\n+  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\\n+  ctx.stroke();\\n+}\\n+\\n+function drawHUDOverlay(ctx) {\\n+  if (!gameState.player) {\\n+    return;\\n+  }\\n+  ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n+  ctx.fillRect(15, 15, 220, 110);\\n+  ctx.fillStyle = '#ffffff';\\n+  ctx.font = '14px \\\"Segoe UI\\\", sans-serif';\\n+  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\\n+  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\\n+  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\\n+  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\\n+  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\\n+  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\\n+}\\n+\\n+function notifyHUD() {\\n+  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\\n+    window.updateHUD(gameState);\\n+  }\\n+  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\\n+    window.showDeathScreen(gameState);\\n+  }\\n+}\\n+\\n+function animationLoop(timestamp) {\\n+  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\\n+  gameState.lastTimestamp = timestamp;\\n+  gameLoop(dt || TARGET_DELTA);\\n+  window.requestAnimationFrame(animationLoop);\\n+}\\n+\\n+window.requestAnimationFrame(animationLoop);\\n+\\n+function setKeyState(key, isDown) {\\n+  if (gameState.keys[key] !== undefined) {\\n+    gameState.keys[key] = isDown;\\n+  }\\n+}\\n+\\n+window.initGame = initGame;\\n+window.triggerGodsayerSword = triggerGodsayerSword;\\n+window.setKeyState = setKeyState;\\n+window.gameState = gameState;\\n+window.spawnWave = spawnWave;\\n+window.spawnBoss = spawnBoss;\\n+window.grantEssence = grantEssence;\\n+window.handleEnemyDeath = handleEnemyDeath;\\n+window.triggerScreenShake = triggerScreenShake;\\n\\n```\\nold_file_revision_id:82ec2a0b-979a-4453-92ed-863a4df5d463\\nnew_file_revision_id:618432e4-6887-439f-8fe9-e93e229b5b13\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "rejected": false}
</TOOL_RESULT>


<TOOL_RUN>
{"tool_call_id": "call_Wwqs3HXaTTl7uOiF5rSoQ3n4", "name": "ToolReadFile", "args": {"filename": "meta/plans/game-js-implementation.md", "pages": ""}}
</TOOL_RUN>


<TOOL_RESULT>
{"tool_call_id": "call_Wwqs3HXaTTl7uOiF5rSoQ3n4", "name": "ToolReadFile", "content": "{\"success\": false, \"error\": \"File not found: meta/plans/game-js-implementation.md\", \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' failed\"}", "content_length": 157, "message": "{\"success\": false, \"error\": \"File not found: meta/plans/game-js-implementation.md\", \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' failed\"}", "rejected": false}
</TOOL_RESULT>



<TOOL_RUN>
{"tool_call_id": "call_npg7eMJWsZ4wJ9hAxJ0wtltt", "name": "ToolListFiles", "args": {"folder": "meta", "mask": "*"}}
</TOOL_RUN>

<TOOL_RESULT>
{"tool_call_id": "call_npg7eMJWsZ4wJ9hAxJ0wtltt", "name": "ToolListFiles", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"Folder meta content:\\nmeta\\\\plans\\\\build-skeleton.md\"}], \"action_name\": \"ToolListFiles\", \"message\": \"Action 'ToolListFiles' completed successfully\"}", "content_length": 203, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"Folder meta content:\\nmeta\\\\plans\\\\build-skeleton.md\"}], \"action_name\": \"ToolListFiles\", \"message\": \"Action 'ToolListFiles' completed successfully\"}", "rejected": false}
</TOOL_RESULT>



<TOOL_RUN>
{"tool_call_id": "call_Hwmtym80ZRmPVba4Vs7ILBOT", "name": "ToolReadFile", "args": {"filename": "meta/plans/build-skeleton.md", "pages": ""}}
</TOOL_RUN>

<TOOL_RESULT>
{"tool_call_id": "call_Hwmtym80ZRmPVba4Vs7ILBOT", "name": "ToolReadFile", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"<filename>meta/plans/build-skeleton.md</filename>\\n<content>\\n---\\nSECTION_ID: plans.build.skeleton_generation\\nTYPE: plan\\nSTATUS: in_progress\\nPRIORITY: high\\n---\\n\\n# Initial Playable Build Generation\\n\\nGOAL: Produce Souls of the Abyss playable skeleton (game.js, index.html, sprites/, animations/) per PROMPTS.md so QA can run tests.\\nTIMELINE: Today\\n\\n## Task Checklist\\n\\n### Phase 1: Code Generation\\n- [x] Review PROMPTS.md requirements for Cody outputs\\n- [*] Delegate PROMPT #1 to Cody \u2192 save game.js\\n- [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\\n\\n### Phase 2: Asset Generation\\n- [ ] Delegate PROMPT #3 to Dali \u2192 populate sprites/\\n- [ ] Delegate PROMPT #4 to Sonic \u2192 populate animations/\\n\\n### Phase 3: Integration & Verification\\n- [ ] Verify file structure + counts match README checklist\\n- [ ] Trigger Jace for initial smoke test once files exist\\n\\n## Success Criteria\\n- [ ] game.js and index.html exist with Cody-spec code (no TODOs)\\n- [ ] sprites/ has required 15 PNGs, animations/ has 14 JSONs\\n- [ ] Basic browser load succeeds; handoff to QA ready\\n\\n</content>\\n<metadata>\\nTotal lines: 32, returned complete file\\n</metadata>\"}], \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' completed successfully\"}", "content_length": 1311, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"<filename>meta/plans/build-skeleton.md</filename>\\n<content>\\n---\\nSECTION_ID: plans.build.skeleton_generation\\nTYPE: plan\\nSTATUS: in_progress\\nPRIORITY: high\\n---\\n\\n# Initial Playable Build Generation\\n\\nGOAL: Produce Souls of the Abyss playable skeleton (game.js, index.html, sprites/, animations/) per PROMPTS.md so QA can run tests.\\nTIMELINE: Today\\n\\n## Task Checklist\\n\\n### Phase 1: Code Generation\\n- [x] Review PROMPTS.md requirements for Cody outputs\\n- [*] Delegate PROMPT #1 to Cody \u2192 save game.js\\n- [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\\n\\n### Phase 2: Asset Generation\\n- [ ] Delegate PROMPT #3 to Dali \u2192 populate sprites/\\n- [ ] Delegate PROMPT #4 to Sonic \u2192 populate animations/\\n\\n### Phase 3: Integration & Verification\\n- [ ] Verify file structure + counts match README checklist\\n- [ ] Trigger Jace for initial smoke test once files exist\\n\\n## Success Criteria\\n- [ ] game.js and index.html exist with Cody-spec code (no TODOs)\\n- [ ] sprites/ has required 15 PNGs, animations/ has 14 JSONs\\n- [ ] Basic browser load succeeds; handoff to QA ready\\n\\n</content>\\n<metadata>\\nTotal lines: 32, returned complete file\\n</metadata>\"}], \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' completed successfully\"}", "rejected": false}
</TOOL_RESULT>


<TOOL_RUN>
{"tool_call_id": "call_j6t3JMLQoFLMpxAdnfJqfJIT", "name": "ToolTextFileEdit", "args": {"short_description": "Update skeleton plan after game.js completion", "filename": "meta/plans/build-skeleton.md", "old_text": "### Phase 1: Code Generation\n- [x] Review PROMPTS.md requirements for Cody outputs\n- [*] Delegate PROMPT #1 to Cody \u2192 save game.js\n- [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\n", "new_text": "### Phase 1: Code Generation\n- [x] Review PROMPTS.md requirements for Cody outputs\n- [x] Delegate PROMPT #1 to Cody \u2192 save game.js (completed, file in repo)\n- [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\n", "preview_only": "false", "skip_validation": "false"}}
</TOOL_RUN>


<TOOL_RESULT>
{"tool_call_id": "call_j6t3JMLQoFLMpxAdnfJqfJIT", "name": "ToolTextFileEdit", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File meta/plans/build-skeleton.md was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/meta/plans/build-skeleton.md\\n+++ b/meta/plans/build-skeleton.md\\n@@ -14,7 +14,7 @@\\n \\n ### Phase 1: Code Generation\\n - [x] Review PROMPTS.md requirements for Cody outputs\\n-- [*] Delegate PROMPT #1 to Cody \u2192 save game.js\\n+- [x] Delegate PROMPT #1 to Cody \u2192 save game.js (completed, file in repo)\\n - [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\\n \\n ### Phase 2: Asset Generation\\n\\n```\\nold_file_revision_id:566b4063-f84b-4ea7-9149-cb4e057dc33c\\nnew_file_revision_id:baecd98f-8d12-4c49-a5e5-8823791e53ee\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "content_length": 764, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File meta/plans/build-skeleton.md was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/meta/plans/build-skeleton.md\\n+++ b/meta/plans/build-skeleton.md\\n@@ -14,7 +14,7 @@\\n \\n ### Phase 1: Code Generation\\n - [x] Review PROMPTS.md requirements for Cody outputs\\n-- [*] Delegate PROMPT #1 to Cody \u2192 save game.js\\n+- [x] Delegate PROMPT #1 to Cody \u2192 save game.js (completed, file in repo)\\n - [ ] Delegate PROMPT #2 to Cody \u2192 save index.html\\n \\n ### Phase 2: Asset Generation\\n\\n```\\nold_file_revision_id:566b4063-f84b-4ea7-9149-cb4e057dc33c\\nnew_file_revision_id:baecd98f-8d12-4c49-a5e5-8823791e53ee\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "rejected": false}
</TOOL_RESULT>


<TOOL_RUN>
{"tool_call_id": "call_dKewtj30B3PvDH76oKs9gqHl", "name": "ToolTextFileEdit", "args": {"short_description": "Adjust player weapon unlock flow", "filename": "game.js", "old_text": "    this.killStreakActive = false;\n    this.killStreakDuration = 5;\n    this.weapons = [];\n    this.manualWeapons = {};\n    this.unlockWeapon('CursedBlade');\n    this.unlockWeapon('GodsayerSword');\n    this.unlockWeapon('ShatterburstAxe');\n    this.unlockWeapon('SoulreaverDagger');\n    this.unlockWeapon('EternalHalberd');\n    this.unlockWeapon('ChaosOrb');\n    this.unlockWeapon('ReapersScythe');\n    this.unlockWeapon('BloodmoonLance');\n    this.unlockWeapon('VoidSummoner');\n    this.weapons = this.weapons.filter((w) => !w.manual);\n    this.sprite.refreshAnimation();\n", "new_text": "    this.killStreakActive = false;\n    this.killStreakDuration = 5;\n    this.weapons = [];\n    this.manualWeapons = {};\n    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();\n    this.unlockWeapon('CursedBlade');\n    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);\n    this.sprite.refreshAnimation();\n", "preview_only": "false", "skip_validation": "false"}}
</TOOL_RUN>


<TOOL_RESULT>
{"tool_call_id": "call_dKewtj30B3PvDH76oKs9gqHl", "name": "ToolTextFileEdit", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -505,16 +505,9 @@\\n     this.killStreakDuration = 5;\\n     this.weapons = [];\\n     this.manualWeapons = {};\\n+    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();\\n     this.unlockWeapon('CursedBlade');\\n-    this.unlockWeapon('GodsayerSword');\\n-    this.unlockWeapon('ShatterburstAxe');\\n-    this.unlockWeapon('SoulreaverDagger');\\n-    this.unlockWeapon('EternalHalberd');\\n-    this.unlockWeapon('ChaosOrb');\\n-    this.unlockWeapon('ReapersScythe');\\n-    this.unlockWeapon('BloodmoonLance');\\n-    this.unlockWeapon('VoidSummoner');\\n-    this.weapons = this.weapons.filter((w) => !w.manual);\\n+    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);\\n     this.sprite.refreshAnimation();\\n   }\\n \\n\\n```\\nold_file_revision_id:b5d35014-9ea2-449a-ab9a-b6fb74893df0\\nnew_file_revision_id:dce516f0-ffc6-4e62-897c-69b939fcbff4\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "content_length": 1132, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -505,16 +505,9 @@\\n     this.killStreakDuration = 5;\\n     this.weapons = [];\\n     this.manualWeapons = {};\\n+    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();\\n     this.unlockWeapon('CursedBlade');\\n-    this.unlockWeapon('GodsayerSword');\\n-    this.unlockWeapon('ShatterburstAxe');\\n-    this.unlockWeapon('SoulreaverDagger');\\n-    this.unlockWeapon('EternalHalberd');\\n-    this.unlockWeapon('ChaosOrb');\\n-    this.unlockWeapon('ReapersScythe');\\n-    this.unlockWeapon('BloodmoonLance');\\n-    this.unlockWeapon('VoidSummoner');\\n-    this.weapons = this.weapons.filter((w) => !w.manual);\\n+    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);\\n     this.sprite.refreshAnimation();\\n   }\\n \\n\\n```\\nold_file_revision_id:b5d35014-9ea2-449a-ab9a-b6fb74893df0\\nnew_file_revision_id:dce516f0-ffc6-4e62-897c-69b939fcbff4\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "rejected": false}
</TOOL_RESULT>


<TOOL_RUN>
{"tool_call_id": "call_fXnwsJh5tR1ky99Zazw1huLP", "name": "ToolTextFileEdit", "args": {"short_description": "Use per-player unlock queue for weapons", "filename": "game.js", "old_text": "      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\n        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\n        if (weaponName) {\n          this.unlockWeapon(weaponName);\n        }\n      }\n", "new_text": "      if (this.level >= 3 && this.pendingUnlocks.length > 0) {\n        const weaponName = this.pendingUnlocks.shift();\n        if (weaponName) {\n          this.unlockWeapon(weaponName);\n        }\n      }\n", "preview_only": "false", "skip_validation": "false"}}
</TOOL_RUN>


<TOOL_RESULT>
{"tool_call_id": "call_fXnwsJh5tR1ky99Zazw1huLP", "name": "ToolTextFileEdit", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -575,8 +575,8 @@\\n       if (this.character === 'knight') {\\n         this.armor += 1;\\n       }\\n-      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\\n-        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\\n+      if (this.level >= 3 && this.pendingUnlocks.length > 0) {\\n+        const weaponName = this.pendingUnlocks.shift();\\n         if (weaponName) {\\n           this.unlockWeapon(weaponName);\\n         }\\n\\n```\\nold_file_revision_id:dce516f0-ffc6-4e62-897c-69b939fcbff4\\nnew_file_revision_id:fb06e9a7-6e1c-4220-a004-21027fa23037\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "content_length": 808, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"success: File game.js was modified successfully:\\n\\nDiff:\\n```diff\\n--- a/game.js\\n+++ b/game.js\\n@@ -575,8 +575,8 @@\\n       if (this.character === 'knight') {\\n         this.armor += 1;\\n       }\\n-      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\\n-        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\\n+      if (this.level >= 3 && this.pendingUnlocks.length > 0) {\\n+        const weaponName = this.pendingUnlocks.shift();\\n         if (weaponName) {\\n           this.unlockWeapon(weaponName);\\n         }\\n\\n```\\nold_file_revision_id:dce516f0-ffc6-4e62-897c-69b939fcbff4\\nnew_file_revision_id:fb06e9a7-6e1c-4220-a004-21027fa23037\"}], \"action_name\": \"ToolTextFileEdit\", \"message\": \"Action 'ToolTextFileEdit' completed successfully\"}", "rejected": false}
</TOOL_RESULT>



<TOOL_RUN>
{"tool_call_id": "call_k3oxmc1kb8XQ5KLTpZrMxGyD", "name": "ToolReadFile", "args": {"filename": "game.js", "pages": ""}}
</TOOL_RUN>

<TOOL_RESULT>
{"tool_call_id": "call_k3oxmc1kb8XQ5KLTpZrMxGyD", "name": "ToolReadFile", "content": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"<filename>game.js</filename>\\n<content>\\nclass Vector2 {\\n  constructor(x = 0, y = 0) {\\n    this.x = x;\\n    this.y = y;\\n  }\\n\\n  clone() {\\n    return new Vector2(this.x, this.y);\\n  }\\n\\n  add(v) {\\n    this.x += v.x;\\n    this.y += v.y;\\n    return this;\\n  }\\n\\n  subtract(v) {\\n    this.x -= v.x;\\n    this.y -= v.y;\\n    return this;\\n  }\\n\\n  scale(s) {\\n    this.x *= s;\\n    this.y *= s;\\n    return this;\\n  }\\n\\n  length() {\\n    return Math.sqrt(this.x * this.x + this.y * this.y);\\n  }\\n\\n  normalize() {\\n    const len = this.length() || 1;\\n    this.x /= len;\\n    this.y /= len;\\n    return this;\\n  }\\n\\n  distance(other) {\\n    const dx = this.x - other.x;\\n    const dy = this.y - other.y;\\n    return Math.sqrt(dx * dx + dy * dy);\\n  }\\n\\n  angle(other) {\\n    return Math.atan2(other.y - this.y, other.x - this.x);\\n  }\\n\\n  static fromAngle(angle, magnitude = 1) {\\n    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\\n  }\\n}\\n\\nconst CANVAS_WIDTH = 1000;\\nconst CANVAS_HEIGHT = 600;\\nconst TARGET_DELTA = 1 / 60;\\nconst DEG_TO_RAD = Math.PI / 180;\\nconst DEFAULT_ANIMATION = {\\n  animations: {\\n    idle: { frameCount: 1, frameTime: 1, loop: true },\\n    run: { frameCount: 1, frameTime: 1, loop: true },\\n    attack: { frameCount: 1, frameTime: 1, loop: false },\\n    hit: { frameCount: 1, frameTime: 1, loop: false },\\n    death: { frameCount: 1, frameTime: 1, loop: false }\\n  }\\n};\\n\\nconst CHARACTER_DEFS = {\\n  knight: {\\n    maxHealth: 100,\\n    baseDamage: 12,\\n    range: 110,\\n    speed: 200,\\n    armor: 5,\\n    spriteSize: 48\\n  },\\n  witch: {\\n    maxHealth: 70,\\n    baseDamage: 8,\\n    range: 140,\\n    speed: 180,\\n    armor: 2,\\n    spriteSize: 48\\n  },\\n  rogue: {\\n    maxHealth: 85,\\n    baseDamage: 10,\\n    range: 90,\\n    speed: 250,\\n    armor: 3,\\n    spriteSize: 48,\\n    dodgeChance: 0.1\\n  }\\n};\\n\\nconst ENEMY_DEFS = {\\n  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\\n  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\\n  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\\n  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\\n  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\\n  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\\n  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\\n};\\n\\nconst BOSS_DEFS = {\\n  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\\n  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\\n  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\\n};\\n\\nconst SOUL_TYPES = {\\n  ethereal: { xp: 10, color: '#f3f6ff' },\\n  essence: { xp: 0, color: '#ffd95a', essence: 1 },\\n  corrupted: { xp: 20, color: '#b21f35' },\\n  cursed: { xp: 50, color: '#0d0d0d' }\\n};\\n\\nconst LEVEL_WEAPON_UNLOCK = [\\n  'ShatterburstAxe',\\n  'SoulreaverDagger',\\n  'EternalHalberd',\\n  'ChaosOrb',\\n  'ReapersScythe',\\n  'BloodmoonLance',\\n  'VoidSummoner'\\n];\\n\\nconst spriteCache = {};\\nconst animationCache = {};\\n\\nfunction getAnimationPath(name) {\\n  return `animations/${name}.json`;\\n}\\n\\nfunction getSprite(name, spriteSize = 48) {\\n  if (spriteCache[name]) {\\n    return spriteCache[name];\\n  }\\n  const sprite = new Sprite(\\n    name,\\n    `sprites/${name}.png`,\\n    spriteSize,\\n    spriteSize,\\n    getAnimationPath(name)\\n  );\\n  spriteCache[name] = sprite;\\n  return sprite;\\n}\\n\\nfunction loadAnimationData(name) {\\n  if (animationCache[name]) {\\n    return animationCache[name];\\n  }\\n  animationCache[name] = DEFAULT_ANIMATION;\\n  fetch(getAnimationPath(name))\\n    .then((resp) => resp.json())\\n    .then((data) => {\\n      animationCache[name] = data.animations ? data : { animations: data };\\n    })\\n    .catch(() => {\\n      animationCache[name] = DEFAULT_ANIMATION;\\n    });\\n  return animationCache[name];\\n}\\n\\nclass Sprite {\\n  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\\n    this.name = name;\\n    this.image = new Image();\\n    this.image.src = imageUrl;\\n    this.imageLoaded = false;\\n    this.imageFailed = false;\\n    this.image.onload = () => {\\n      this.imageLoaded = true;\\n    };\\n    this.image.onerror = () => {\\n      this.imageFailed = true;\\n    };\\n    this.frameWidth = frameWidth;\\n    this.frameHeight = frameHeight;\\n    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\\n    this.currentState = 'idle';\\n    this.animationTime = 0;\\n    this.frameIndex = 0;\\n    this.colorFallback = '#ffffff';\\n    this.animationPath = animationPath;\\n    this.refreshAnimation();\\n  }\\n\\n  refreshAnimation() {\\n    fetch(this.animationPath)\\n      .then((resp) => resp.json())\\n      .then((data) => {\\n        this.animationData = data.animations ? data : { animations: data };\\n      })\\n      .catch(() => {\\n        this.animationData = DEFAULT_ANIMATION;\\n      });\\n  }\\n\\n  update(dt, desiredState = 'idle') {\\n    if (this.currentState !== desiredState) {\\n      this.currentState = desiredState;\\n      this.animationTime = 0;\\n    } else {\\n      this.animationTime += dt;\\n    }\\n    const animSpec = this.getAnimationSpec(this.currentState);\\n    const totalDuration = animSpec.frameCount * animSpec.frameTime;\\n    if (animSpec.loop) {\\n      this.animationTime = this.animationTime % (totalDuration || 1);\\n    } else if (this.animationTime > totalDuration) {\\n      this.animationTime = totalDuration - animSpec.frameTime;\\n    }\\n    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\\n  }\\n\\n  getAnimationSpec(state) {\\n    const data = this.animationData.animations || this.animationData;\\n    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\\n  }\\n\\n  draw(ctx, x, y, scale = 1, flipX = false) {\\n    if (this.imageLoaded && !this.imageFailed) {\\n      const animSpec = this.getAnimationSpec(this.currentState);\\n      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\\n      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\\n      const srcY = 0;\\n      const destWidth = this.frameWidth * scale;\\n      const destHeight = this.frameHeight * scale;\\n      ctx.save();\\n      if (flipX) {\\n        ctx.translate(x + destWidth, y);\\n        ctx.scale(-1, 1);\\n        ctx.drawImage(\\n          this.image,\\n          srcX,\\n          srcY,\\n          this.frameWidth,\\n          this.frameHeight,\\n          0,\\n          0,\\n          destWidth,\\n          destHeight\\n        );\\n      } else {\\n        ctx.drawImage(\\n          this.image,\\n          srcX,\\n          srcY,\\n          this.frameWidth,\\n          this.frameHeight,\\n          x,\\n          y,\\n          destWidth,\\n          destHeight\\n        );\\n      }\\n      ctx.restore();\\n    } else {\\n      ctx.fillStyle = this.colorFallback;\\n      ctx.beginPath();\\n      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\\n      ctx.fill();\\n    }\\n  }\\n}\\n\\nclass Particle {\\n  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\\n    this.position = new Vector2(x, y);\\n    this.velocity = new Vector2(vx, vy);\\n    this.lifetime = lifetime;\\n    this.remaining = lifetime;\\n    this.color = color;\\n    this.type = type;\\n    this.size = type === 'explosion' ? 10 : 4;\\n  }\\n\\n  update(dt) {\\n    this.remaining -= dt;\\n    if (this.type === 'blood' || this.type === 'spark') {\\n      this.velocity.y += 30 * dt;\\n    }\\n    this.position.add(this.velocity.clone().scale(dt));\\n  }\\n\\n  draw(ctx) {\\n    if (this.remaining <= 0) {\\n      return;\\n    }\\n    const alpha = Math.max(this.remaining / this.lifetime, 0);\\n    ctx.save();\\n    ctx.globalAlpha = alpha;\\n    if (this.type === 'glow') {\\n      const gradient = ctx.createRadialGradient(\\n        this.position.x,\\n        this.position.y,\\n        0,\\n        this.position.x,\\n        this.position.y,\\n        this.size * 2\\n      );\\n      gradient.addColorStop(0, this.color);\\n      gradient.addColorStop(1, 'transparent');\\n      ctx.fillStyle = gradient;\\n      ctx.beginPath();\\n      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\\n      ctx.fill();\\n    } else {\\n      ctx.fillStyle = this.color;\\n      ctx.beginPath();\\n      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\\n      ctx.fill();\\n    }\\n    ctx.restore();\\n  }\\n}\\n\\nclass Projectile {\\n  constructor(config) {\\n    this.position = config.position.clone();\\n    this.velocity = config.velocity.clone();\\n    this.damage = config.damage;\\n    this.range = config.range;\\n    this.traveled = 0;\\n    this.radius = config.radius || 6;\\n    this.pierce = config.pierce || 1;\\n    this.owner = config.owner;\\n    this.lifesteal = config.lifesteal || 0;\\n    this.color = config.color || '#ffffff';\\n  }\\n\\n  update(dt) {\\n    const movement = this.velocity.clone().scale(dt);\\n    this.position.add(movement);\\n    this.traveled += movement.length();\\n  }\\n\\n  isExpired() {\\n    return this.traveled >= this.range;\\n  }\\n\\n  draw(ctx) {\\n    ctx.fillStyle = this.color;\\n    ctx.beginPath();\\n    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nclass Soul {\\n  constructor(x, y, type) {\\n    this.position = new Vector2(x, y);\\n    this.type = type;\\n    this.radius = 8;\\n    this.floatTimer = 0;\\n    this.collected = false;\\n  }\\n\\n  update(dt, player) {\\n    this.floatTimer += dt;\\n    const bob = Math.sin(this.floatTimer * 3) * 2;\\n    if (player && player.position.distance(this.position) < 25) {\\n      this.collected = true;\\n      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\\n      if (SOUL_TYPES[this.type].essence) {\\n        grantEssence(SOUL_TYPES[this.type].essence);\\n      }\\n    }\\n    this.renderOffset = bob;\\n  }\\n\\n  draw(ctx) {\\n    ctx.fillStyle = SOUL_TYPES[this.type].color;\\n    ctx.beginPath();\\n    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nclass Weapon {\\n  constructor(name, config) {\\n    this.name = name;\\n    this.damage = config.damage;\\n    this.fireRate = config.fireRate || 1;\\n    this.range = config.range || 100;\\n    this.type = config.type;\\n    this.cost = config.cost || 0;\\n    this.manual = config.manual || false;\\n    this.cooldown = 0;\\n    this.execute = config.execute;\\n    this.lifesteal = config.lifesteal || 0;\\n    this.extra = config.extra || {};\\n  }\\n\\n  update(dt, player, enemies) {\\n    if (this.manual) {\\n      return;\\n    }\\n    this.cooldown -= dt;\\n    if (this.cooldown <= 0) {\\n      const fired = this.execute(player, enemies, this);\\n      if (fired) {\\n        this.cooldown = 1 / this.fireRate;\\n      }\\n    }\\n  }\\n\\n  trigger(player, enemies) {\\n    return this.execute(player, enemies, this);\\n  }\\n}\\n\\nclass Enemy {\\n  constructor(type, x, y, isBoss = false) {\\n    this.type = type;\\n    this.isBoss = isBoss;\\n    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\\n    this.maxHealth = this.definition.health;\\n    this.health = this.maxHealth;\\n    this.damage = this.definition.damage;\\n    this.speed = this.definition.speed;\\n    this.position = new Vector2(x, y);\\n    this.velocity = new Vector2();\\n    this.alive = true;\\n    this.state = 'idle';\\n    this.deathTimer = 0;\\n    this.sprite = getSprite(type, this.definition.spriteSize || 48);\\n    this.sprite.colorFallback = this.definition.color;\\n  }\\n\\n  update(dt, player, multiplier) {\\n    if (!this.alive) {\\n      this.deathTimer += dt;\\n      this.sprite.update(dt, 'death');\\n      return;\\n    }\\n    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\\n    const distance = Math.max(toPlayer.length(), 0.0001);\\n    const direction = toPlayer.clone().scale(1 / distance);\\n    const effectiveSpeed = this.speed * multiplier;\\n    if (this.type === 'wraith') {\\n      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\\n      direction.add(swirl).normalize();\\n    }\\n    this.velocity = direction.clone().scale(effectiveSpeed);\\n    this.position.add(this.velocity.clone().scale(dt));\\n    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\\n  }\\n\\n  takeDamage(amount) {\\n    if (!this.alive) {\\n      return false;\\n    }\\n    this.health -= amount;\\n    if (this.health <= 0) {\\n      this.alive = false;\\n      this.state = 'death';\\n      return true;\\n    }\\n    this.state = 'hit';\\n    return false;\\n  }\\n\\n  draw(ctx) {\\n    const size = this.definition.spriteSize || 48;\\n    const drawX = this.position.x - size * 0.5;\\n    const drawY = this.position.y - size * 0.5;\\n    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\\n    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\\n    if (this.alive) {\\n      ctx.fillStyle = '#222';\\n      ctx.fillRect(drawX, drawY - 10, size, 4);\\n      ctx.fillStyle = '#e63946';\\n      const hpRatio = Math.max(this.health / this.maxHealth, 0);\\n      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\\n    }\\n  }\\n}\\n\\nclass Player {\\n  constructor(character) {\\n    const def = CHARACTER_DEFS[character];\\n    this.character = character;\\n    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\\n    this.velocity = new Vector2();\\n    this.speed = def.speed;\\n    this.range = def.range;\\n    this.maxHealth = def.maxHealth;\\n    this.health = def.maxHealth;\\n    this.baseDamage = def.baseDamage;\\n    this.level = 1;\\n    this.experience = 0;\\n    this.nextLevelExp = 100;\\n    this.armor = def.armor || 0;\\n    this.sprite = getSprite(character, def.spriteSize);\\n    this.sprite.colorFallback = '#f5f3f4';\\n    this.state = 'idle';\\n    this.killStreak = 0;\\n    this.killStreakTimer = 0;\\n    this.killStreakActive = false;\\n    this.killStreakDuration = 5;\\n    this.weapons = [];\\n    this.manualWeapons = {};\\n    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();\\n    this.unlockWeapon('CursedBlade');\\n    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);\\n    this.sprite.refreshAnimation();\\n  }\\n\\n  unlockWeapon(name) {\\n    if (!WEAPON_CONFIGS[name]) {\\n      return;\\n    }\\n    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\\n    if (weapon.manual) {\\n      this.manualWeapons[name] = weapon;\\n    } else {\\n      this.weapons.push(weapon);\\n    }\\n  }\\n\\n  update(dt, state) {\\n    const keys = state.keys;\\n    const input = new Vector2(\\n      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\\n      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\\n    );\\n    if (input.length() > 0) {\\n      input.normalize();\\n      this.velocity = input.clone().scale(this.speed);\\n      this.state = 'run';\\n    } else {\\n      this.velocity = new Vector2();\\n      this.state = 'idle';\\n    }\\n    this.position.add(this.velocity.clone().scale(dt));\\n    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\\n    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\\n    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\\n    if (this.killStreakActive) {\\n      this.killStreakTimer -= dt;\\n      if (this.killStreakTimer <= 0) {\\n        this.killStreakActive = false;\\n        this.killStreak = 0;\\n      }\\n    }\\n    this.sprite.update(dt, this.state);\\n  }\\n\\n  takeDamage(amount) {\\n    if (this.character === 'rogue' && Math.random() < 0.1) {\\n      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\\n      return;\\n    }\\n    const mitigated = Math.max(amount - this.armor, 1);\\n    this.health -= mitigated;\\n    if (this.health <= 0) {\\n      this.health = 0;\\n      gameState.alive = false;\\n    }\\n  }\\n\\n  gainExperience(amount) {\\n    this.experience += amount;\\n    while (this.experience >= this.nextLevelExp) {\\n      this.experience -= this.nextLevelExp;\\n      this.level += 1;\\n      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\\n      this.maxHealth += 5;\\n      this.health = this.maxHealth;\\n      if (this.character === 'knight') {\\n        this.armor += 1;\\n      }\\n      if (this.level >= 3 && this.pendingUnlocks.length > 0) {\\n        const weaponName = this.pendingUnlocks.shift();\\n        if (weaponName) {\\n          this.unlockWeapon(weaponName);\\n        }\\n      }\\n    }\\n  }\\n\\n  registerKill() {\\n    this.killStreak += 1;\\n    if (this.character === 'rogue' && this.killStreak >= 5) {\\n      this.killStreakActive = true;\\n      this.killStreakTimer = this.killStreakDuration;\\n    }\\n  }\\n\\n  getDamageMultiplier() {\\n    let multiplier = 1 + (this.level - 1) * 0.05;\\n    if (this.killStreakActive) {\\n      multiplier += 0.15;\\n    }\\n    return multiplier;\\n  }\\n\\n  draw(ctx) {\\n    const size = CHARACTER_DEFS[this.character].spriteSize;\\n    const drawX = this.position.x - size * 0.5;\\n    const drawY = this.position.y - size * 0.5;\\n    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\\n    ctx.fillStyle = '#222';\\n    ctx.fillRect(drawX, drawY - 12, size, 5);\\n    ctx.fillStyle = '#7cf5ff';\\n    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\\n  }\\n}\\n\\nconst WEAPON_CONFIGS = {\\n  CursedBlade: {\\n    damage: 10,\\n    fireRate: 1,\\n    range: 100,\\n    type: 'cone',\\n    execute: (player, enemies, weapon) => {\\n      let hit = false;\\n      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) {\\n          return;\\n        }\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const angleToEnemy = Math.atan2(\\n            enemy.position.y - player.position.y,\\n            enemy.position.x - player.position.x\\n          );\\n          let delta = angleToEnemy - facingAngle;\\n          while (delta > Math.PI) delta -= Math.PI * 2;\\n          while (delta < -Math.PI) delta += Math.PI * 2;\\n          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            hit = hit || killed;\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n          }\\n        }\\n      });\\n      if (hit) {\\n        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\\n      }\\n      return true;\\n    }\\n  },\\n  ShatterburstAxe: {\\n    damage: 15,\\n    fireRate: 0.8,\\n    range: 60,\\n    type: 'aoe',\\n    execute: (player, enemies, weapon) => {\\n      let any = false;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        if (player.position.distance(enemy.position) <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          any = any || killed;\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          } else {\\n            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\\n            enemy.position.add(push);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\\n      return true;\\n    }\\n  },\\n  SoulreaverDagger: {\\n    damage: 5,\\n    fireRate: 2,\\n    range: 30,\\n    type: 'multi-hit',\\n    execute: (player, enemies, weapon) => {\\n      let target = null;\\n      let closest = Infinity;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance < closest && distance <= weapon.range) {\\n          closest = distance;\\n          target = enemy;\\n        }\\n      });\\n      if (!target) {\\n        return false;\\n      }\\n      for (let i = 0; i < 3; i += 1) {\\n        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\\n        if (killed) {\\n          handleEnemyDeath(target);\\n          break;\\n        }\\n        player.health = Math.min(\\n          player.maxHealth,\\n          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\\n        );\\n      }\\n      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\\n      return true;\\n    }\\n  },\\n  EternalHalberd: {\\n    damage: 25,\\n    fireRate: 0.5,\\n    range: 80,\\n    type: 'aoe',\\n    execute: (player, enemies, weapon) => {\\n      let hitAny = false;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          hitAny = hitAny || killed;\\n          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\\n          enemy.position.add(pull.scale(0.1));\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\\n      return true;\\n    }\\n  },\\n  ChaosOrb: {\\n    damage: 8,\\n    fireRate: 1.2,\\n    range: 300,\\n    type: 'projectile',\\n    execute: (player) => {\\n      const orbCount = 2 + Math.floor(Math.random() * 3);\\n      for (let i = 0; i < orbCount; i += 1) {\\n        const angle = Math.random() * Math.PI * 2;\\n        const velocity = Vector2.fromAngle(angle, 200);\\n        gameState.projectiles.push(\\n          new Projectile({\\n            position: player.position.clone(),\\n            velocity,\\n            damage: 8 * player.getDamageMultiplier(),\\n            range: 320,\\n            pierce: 3,\\n            owner: player,\\n            color: '#7bed9f'\\n          })\\n        );\\n      }\\n      return true;\\n    }\\n  },\\n  ReapersScythe: {\\n    damage: 20,\\n    fireRate: 0.8,\\n    range: 100,\\n    type: 'spin',\\n    execute: (player, enemies, weapon) => {\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          } else {\\n            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\\n            enemy.position.add(pull);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\\n      return true;\\n    }\\n  },\\n  BloodmoonLance: {\\n    damage: 20,\\n    fireRate: 1,\\n    range: 400,\\n    type: 'beam',\\n    lifesteal: 0.5,\\n    execute: (player, enemies, weapon) => {\\n      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const toEnemy = enemy.position.clone().subtract(player.position);\\n        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\\n        if (projection >= 0 && projection <= weapon.range) {\\n          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\\n          if (perpendicular <= 40) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n            player.health = Math.min(\\n              player.maxHealth,\\n              player.health + weapon.damage * weapon.lifesteal\\n            );\\n          }\\n        }\\n      });\\n      spawnParticleBurst(\\n        player.position.x + direction.x * 60,\\n        player.position.y + direction.y * 60,\\n        '#ff99c8',\\n        'glow',\\n        14\\n      );\\n      return true;\\n    }\\n  },\\n  GodsayerSword: {\\n    damage: 100,\\n    fireRate: 1,\\n    range: 150,\\n    type: 'manual',\\n    manual: true,\\n    cost: 1,\\n    execute: (player, enemies, weapon) => {\\n      if (gameState.weaponCharges < weapon.cost) {\\n        return false;\\n      }\\n      gameState.weaponCharges -= weapon.cost;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        if (player.position.distance(enemy.position) <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\\n      triggerScreenShake();\\n      return true;\\n    }\\n  },\\n  VoidSummoner: {\\n    damage: 15,\\n    fireRate: 0.125,\\n    range: 200,\\n    cost: 2,\\n    type: 'summon',\\n    execute: (player, enemies, weapon) => {\\n      if (gameState.weaponCharges < weapon.cost) {\\n        return false;\\n      }\\n      gameState.weaponCharges -= weapon.cost;\\n      for (let i = 0; i < 3; i += 1) {\\n        const angle = (Math.PI * 2 * i) / 3;\\n        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\\n        enemies.forEach((enemy) => {\\n          if (!enemy.alive) return;\\n          if (summonPos.distance(enemy.position) <= 70) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n          }\\n        });\\n        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\\n      }\\n      return true;\\n    }\\n  }\\n};\\n\\nconst gameState = {\\n  canvas: null,\\n  ctx: null,\\n  player: null,\\n  enemies: [],\\n  souls: [],\\n  particles: [],\\n  projectiles: [],\\n  alive: false,\\n  keys: { w: false, a: false, s: false, d: false },\\n  gameTime: 0,\\n  waveTimer: 0,\\n  waveNumber: 0,\\n  bossTimer: 0,\\n  bossIndex: 0,\\n  enemiesKilled: 0,\\n  difficultyMultiplier: 1,\\n  weaponCharges: 0,\\n  essenceCollected: 0,\\n  pendingGodsayer: false,\\n  screenShake: 0,\\n  lastTimestamp: performance.now()\\n};\\n\\nfunction ensureCanvas() {\\n  if (!gameState.canvas) {\\n    gameState.canvas = document.getElementById('gameCanvas');\\n    if (gameState.canvas) {\\n      gameState.ctx = gameState.canvas.getContext('2d');\\n    }\\n  }\\n}\\n\\nfunction initGame(character = 'knight') {\\n  ensureCanvas();\\n  gameState.player = new Player(character);\\n  gameState.enemies = [];\\n  gameState.souls = [];\\n  gameState.particles = [];\\n  gameState.projectiles = [];\\n  gameState.gameTime = 0;\\n  gameState.waveTimer = 0;\\n  gameState.waveNumber = 0;\\n  gameState.bossTimer = 0;\\n  gameState.enemiesKilled = 0;\\n  gameState.weaponCharges = 0;\\n  gameState.essenceCollected = 0;\\n  gameState.alive = true;\\n  gameState.screenShake = 0;\\n}\\n\\nfunction spawnWave() {\\n  if (!gameState.player) {\\n    return;\\n  }\\n  const count = 5 + gameState.waveNumber * 2;\\n  for (let i = 0; i < count; i += 1) {\\n    const isElite = Math.random() < 0.2;\\n    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\\n    const type = pool[Math.floor(Math.random() * pool.length)];\\n    const angle = Math.random() * Math.PI * 2;\\n    const spawnRadius = 150 + Math.random() * 100;\\n    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\\n    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\\n    gameState.enemies.push(new Enemy(type, posX, posY));\\n  }\\n  gameState.waveNumber += 1;\\n  gameState.waveTimer = 0;\\n}\\n\\nfunction spawnBoss() {\\n  const bossKeys = Object.keys(BOSS_DEFS);\\n  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\\n  gameState.bossIndex += 1;\\n  const edge = Math.floor(Math.random() * 4);\\n  let x = 0;\\n  let y = 0;\\n  if (edge === 0) {\\n    x = Math.random() * CANVAS_WIDTH;\\n    y = -50;\\n  } else if (edge === 1) {\\n    x = CANVAS_WIDTH + 50;\\n    y = Math.random() * CANVAS_HEIGHT;\\n  } else if (edge === 2) {\\n    x = Math.random() * CANVAS_WIDTH;\\n    y = CANVAS_HEIGHT + 50;\\n  } else {\\n    x = -50;\\n    y = Math.random() * CANVAS_HEIGHT;\\n  }\\n  const boss = new Enemy(bossName, x, y, true);\\n  gameState.enemies.push(boss);\\n  gameState.bossTimer = 0;\\n  triggerScreenShake(20);\\n}\\n\\nfunction grantEssence(amount) {\\n  gameState.essenceCollected += amount;\\n  if (gameState.essenceCollected >= 5) {\\n    const charges = Math.floor(gameState.essenceCollected / 5);\\n    gameState.weaponCharges += charges;\\n    gameState.essenceCollected -= charges * 5;\\n  }\\n}\\n\\nfunction handleEnemyDeath(enemy) {\\n  if (!enemy) {\\n    return;\\n  }\\n  gameState.enemiesKilled += 1;\\n  if (gameState.player) {\\n    gameState.player.registerKill();\\n  }\\n  dropSoul(enemy);\\n  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\\n}\\n\\nfunction dropSoul(enemy) {\\n  if (enemy.isBoss) {\\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\\n    return;\\n  }\\n  if (ENEMY_DEFS[enemy.type].elite) {\\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\\n    if (Math.random() < 0.4) {\\n      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\\n    }\\n  } else {\\n    if (Math.random() < 0.95) {\\n      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\\n    }\\n    if (Math.random() < 0.05) {\\n      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\\n    }\\n  }\\n}\\n\\nfunction spawnParticleBurst(x, y, color, type, count) {\\n  for (let i = 0; i < count; i += 1) {\\n    const angle = Math.random() * Math.PI * 2;\\n    const speed = 40 + Math.random() * 120;\\n    const vx = Math.cos(angle) * speed;\\n    const vy = Math.sin(angle) * speed;\\n    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\\n    gameState.particles.push(particle);\\n  }\\n}\\n\\nfunction triggerScreenShake(intensity = 10) {\\n  gameState.screenShake = Math.max(gameState.screenShake, intensity);\\n}\\n\\nfunction updateProjectiles(dt) {\\n  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\\n    const projectile = gameState.projectiles[i];\\n    projectile.update(dt);\\n    let removed = false;\\n    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\\n      const enemy = gameState.enemies[j];\\n      if (!enemy.alive) continue;\\n      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\\n        const killed = enemy.takeDamage(projectile.damage);\\n        if (killed) {\\n          handleEnemyDeath(enemy);\\n        }\\n        projectile.pierce -= 1;\\n        if (projectile.lifesteal && gameState.player) {\\n          gameState.player.health = Math.min(\\n            gameState.player.maxHealth,\\n            gameState.player.health + projectile.damage * projectile.lifesteal\\n          );\\n        }\\n        if (projectile.pierce <= 0) {\\n          removed = true;\\n          break;\\n        }\\n      }\\n    }\\n    if (projectile.isExpired() || removed) {\\n      gameState.projectiles.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateSouls(dt) {\\n  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\\n    const soul = gameState.souls[i];\\n    soul.update(dt, gameState.player);\\n    if (soul.collected) {\\n      gameState.souls.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateParticles(dt) {\\n  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\\n    const particle = gameState.particles[i];\\n    particle.update(dt);\\n    if (particle.remaining <= 0) {\\n      gameState.particles.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateEnemies(dt) {\\n  const player = gameState.player;\\n  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\\n    const enemy = gameState.enemies[i];\\n    enemy.update(dt, player, gameState.difficultyMultiplier);\\n    if (!enemy.alive && enemy.deathTimer > 1.5) {\\n      gameState.enemies.splice(i, 1);\\n    }\\n    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\\n      const damage = enemy.damage;\\n      player.takeDamage(damage);\\n      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\\n    }\\n  }\\n}\\n\\nfunction triggerGodsayerSword() {\\n  if (!gameState.player) {\\n    return false;\\n  }\\n  const weapon = gameState.player.manualWeapons.GodsayerSword;\\n  if (!weapon) {\\n    return false;\\n  }\\n  return weapon.trigger(gameState.player, gameState.enemies);\\n}\\n\\nfunction gameLoop(dt) {\\n  ensureCanvas();\\n  if (!gameState.ctx) {\\n    return;\\n  }\\n  if (gameState.player && gameState.alive) {\\n    gameState.gameTime += dt;\\n    gameState.waveTimer += dt;\\n    gameState.bossTimer += dt;\\n    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\\n    gameState.player.update(dt, gameState);\\n    updateEnemies(dt);\\n    updateProjectiles(dt);\\n    updateSouls(dt);\\n    updateParticles(dt);\\n    if (gameState.waveTimer >= 30) {\\n      spawnWave();\\n    }\\n    if (gameState.bossTimer >= 120) {\\n      spawnBoss();\\n    }\\n    if (gameState.player.health <= 0) {\\n      gameState.alive = false;\\n    }\\n  }\\n  drawGame();\\n  notifyHUD();\\n}\\n\\nfunction drawGame() {\\n  const ctx = gameState.ctx;\\n  if (!ctx) {\\n    return;\\n  }\\n  ctx.save();\\n  if (gameState.screenShake > 0) {\\n    ctx.translate(\\n      (Math.random() - 0.5) * gameState.screenShake,\\n      (Math.random() - 0.5) * gameState.screenShake\\n    );\\n    gameState.screenShake *= 0.9;\\n  }\\n  drawBackground(ctx);\\n  gameState.souls.forEach((soul) => soul.draw(ctx));\\n  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\\n  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\\n  if (gameState.player) {\\n    gameState.player.draw(ctx);\\n  }\\n  gameState.particles.forEach((particle) => particle.draw(ctx));\\n  drawHUDOverlay(ctx);\\n  ctx.restore();\\n}\\n\\nfunction drawBackground(ctx) {\\n  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\\n  gradient.addColorStop(0, '#1a0327');\\n  gradient.addColorStop(0.5, '#1f1f49');\\n  gradient.addColorStop(1, '#040308');\\n  ctx.fillStyle = gradient;\\n  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\\n  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\\n  for (let i = 0; i < 8; i += 1) {\\n    const angle = (Math.PI * 2 * i) / 8;\\n    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\\n    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\\n    ctx.beginPath();\\n    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\\n    ctx.stroke();\\n  }\\n  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\\n  ctx.beginPath();\\n  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\\n  ctx.stroke();\\n}\\n\\nfunction drawHUDOverlay(ctx) {\\n  if (!gameState.player) {\\n    return;\\n  }\\n  ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n  ctx.fillRect(15, 15, 220, 110);\\n  ctx.fillStyle = '#ffffff';\\n  ctx.font = '14px \\\"Segoe UI\\\", sans-serif';\\n  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\\n  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\\n  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\\n  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\\n  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\\n  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\\n}\\n\\nfunction notifyHUD() {\\n  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\\n    window.updateHUD(gameState);\\n  }\\n  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\\n    window.showDeathScreen(gameState);\\n  }\\n}\\n\\nfunction animationLoop(timestamp) {\\n  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\\n  gameState.lastTimestamp = timestamp;\\n  gameLoop(dt || TARGET_DELTA);\\n  window.requestAnimationFrame(animationLoop);\\n}\\n\\nwindow.requestAnimationFrame(animationLoop);\\n\\nfunction setKeyState(key, isDown) {\\n  if (gameState.keys[key] !== undefined) {\\n    gameState.keys[key] = isDown;\\n  }\\n}\\n\\nwindow.initGame = initGame;\\nwindow.triggerGodsayerSword = triggerGodsayerSword;\\nwindow.setKeyState = setKeyState;\\nwindow.gameState = gameState;\\nwindow.spawnWave = spawnWave;\\nwindow.spawnBoss = spawnBoss;\\nwindow.grantEssence = grantEssence;\\nwindow.handleEnemyDeath = handleEnemyDeath;\\nwindow.triggerScreenShake = triggerScreenShake;\\n\\n</content>\\n<metadata>\\nTotal lines: 1230, returned complete file\\n</metadata>\"}], \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' completed successfully\"}", "content_length": 36939, "message": "{\"success\": true, \"result\": [{\"type\": \"text\", \"text\": \"<filename>game.js</filename>\\n<content>\\nclass Vector2 {\\n  constructor(x = 0, y = 0) {\\n    this.x = x;\\n    this.y = y;\\n  }\\n\\n  clone() {\\n    return new Vector2(this.x, this.y);\\n  }\\n\\n  add(v) {\\n    this.x += v.x;\\n    this.y += v.y;\\n    return this;\\n  }\\n\\n  subtract(v) {\\n    this.x -= v.x;\\n    this.y -= v.y;\\n    return this;\\n  }\\n\\n  scale(s) {\\n    this.x *= s;\\n    this.y *= s;\\n    return this;\\n  }\\n\\n  length() {\\n    return Math.sqrt(this.x * this.x + this.y * this.y);\\n  }\\n\\n  normalize() {\\n    const len = this.length() || 1;\\n    this.x /= len;\\n    this.y /= len;\\n    return this;\\n  }\\n\\n  distance(other) {\\n    const dx = this.x - other.x;\\n    const dy = this.y - other.y;\\n    return Math.sqrt(dx * dx + dy * dy);\\n  }\\n\\n  angle(other) {\\n    return Math.atan2(other.y - this.y, other.x - this.x);\\n  }\\n\\n  static fromAngle(angle, magnitude = 1) {\\n    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\\n  }\\n}\\n\\nconst CANVAS_WIDTH = 1000;\\nconst CANVAS_HEIGHT = 600;\\nconst TARGET_DELTA = 1 / 60;\\nconst DEG_TO_RAD = Math.PI / 180;\\nconst DEFAULT_ANIMATION = {\\n  animations: {\\n    idle: { frameCount: 1, frameTime: 1, loop: true },\\n    run: { frameCount: 1, frameTime: 1, loop: true },\\n    attack: { frameCount: 1, frameTime: 1, loop: false },\\n    hit: { frameCount: 1, frameTime: 1, loop: false },\\n    death: { frameCount: 1, frameTime: 1, loop: false }\\n  }\\n};\\n\\nconst CHARACTER_DEFS = {\\n  knight: {\\n    maxHealth: 100,\\n    baseDamage: 12,\\n    range: 110,\\n    speed: 200,\\n    armor: 5,\\n    spriteSize: 48\\n  },\\n  witch: {\\n    maxHealth: 70,\\n    baseDamage: 8,\\n    range: 140,\\n    speed: 180,\\n    armor: 2,\\n    spriteSize: 48\\n  },\\n  rogue: {\\n    maxHealth: 85,\\n    baseDamage: 10,\\n    range: 90,\\n    speed: 250,\\n    armor: 3,\\n    spriteSize: 48,\\n    dodgeChance: 0.1\\n  }\\n};\\n\\nconst ENEMY_DEFS = {\\n  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\\n  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\\n  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\\n  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\\n  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\\n  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\\n  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\\n};\\n\\nconst BOSS_DEFS = {\\n  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\\n  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\\n  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\\n};\\n\\nconst SOUL_TYPES = {\\n  ethereal: { xp: 10, color: '#f3f6ff' },\\n  essence: { xp: 0, color: '#ffd95a', essence: 1 },\\n  corrupted: { xp: 20, color: '#b21f35' },\\n  cursed: { xp: 50, color: '#0d0d0d' }\\n};\\n\\nconst LEVEL_WEAPON_UNLOCK = [\\n  'ShatterburstAxe',\\n  'SoulreaverDagger',\\n  'EternalHalberd',\\n  'ChaosOrb',\\n  'ReapersScythe',\\n  'BloodmoonLance',\\n  'VoidSummoner'\\n];\\n\\nconst spriteCache = {};\\nconst animationCache = {};\\n\\nfunction getAnimationPath(name) {\\n  return `animations/${name}.json`;\\n}\\n\\nfunction getSprite(name, spriteSize = 48) {\\n  if (spriteCache[name]) {\\n    return spriteCache[name];\\n  }\\n  const sprite = new Sprite(\\n    name,\\n    `sprites/${name}.png`,\\n    spriteSize,\\n    spriteSize,\\n    getAnimationPath(name)\\n  );\\n  spriteCache[name] = sprite;\\n  return sprite;\\n}\\n\\nfunction loadAnimationData(name) {\\n  if (animationCache[name]) {\\n    return animationCache[name];\\n  }\\n  animationCache[name] = DEFAULT_ANIMATION;\\n  fetch(getAnimationPath(name))\\n    .then((resp) => resp.json())\\n    .then((data) => {\\n      animationCache[name] = data.animations ? data : { animations: data };\\n    })\\n    .catch(() => {\\n      animationCache[name] = DEFAULT_ANIMATION;\\n    });\\n  return animationCache[name];\\n}\\n\\nclass Sprite {\\n  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\\n    this.name = name;\\n    this.image = new Image();\\n    this.image.src = imageUrl;\\n    this.imageLoaded = false;\\n    this.imageFailed = false;\\n    this.image.onload = () => {\\n      this.imageLoaded = true;\\n    };\\n    this.image.onerror = () => {\\n      this.imageFailed = true;\\n    };\\n    this.frameWidth = frameWidth;\\n    this.frameHeight = frameHeight;\\n    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\\n    this.currentState = 'idle';\\n    this.animationTime = 0;\\n    this.frameIndex = 0;\\n    this.colorFallback = '#ffffff';\\n    this.animationPath = animationPath;\\n    this.refreshAnimation();\\n  }\\n\\n  refreshAnimation() {\\n    fetch(this.animationPath)\\n      .then((resp) => resp.json())\\n      .then((data) => {\\n        this.animationData = data.animations ? data : { animations: data };\\n      })\\n      .catch(() => {\\n        this.animationData = DEFAULT_ANIMATION;\\n      });\\n  }\\n\\n  update(dt, desiredState = 'idle') {\\n    if (this.currentState !== desiredState) {\\n      this.currentState = desiredState;\\n      this.animationTime = 0;\\n    } else {\\n      this.animationTime += dt;\\n    }\\n    const animSpec = this.getAnimationSpec(this.currentState);\\n    const totalDuration = animSpec.frameCount * animSpec.frameTime;\\n    if (animSpec.loop) {\\n      this.animationTime = this.animationTime % (totalDuration || 1);\\n    } else if (this.animationTime > totalDuration) {\\n      this.animationTime = totalDuration - animSpec.frameTime;\\n    }\\n    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\\n  }\\n\\n  getAnimationSpec(state) {\\n    const data = this.animationData.animations || this.animationData;\\n    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\\n  }\\n\\n  draw(ctx, x, y, scale = 1, flipX = false) {\\n    if (this.imageLoaded && !this.imageFailed) {\\n      const animSpec = this.getAnimationSpec(this.currentState);\\n      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\\n      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\\n      const srcY = 0;\\n      const destWidth = this.frameWidth * scale;\\n      const destHeight = this.frameHeight * scale;\\n      ctx.save();\\n      if (flipX) {\\n        ctx.translate(x + destWidth, y);\\n        ctx.scale(-1, 1);\\n        ctx.drawImage(\\n          this.image,\\n          srcX,\\n          srcY,\\n          this.frameWidth,\\n          this.frameHeight,\\n          0,\\n          0,\\n          destWidth,\\n          destHeight\\n        );\\n      } else {\\n        ctx.drawImage(\\n          this.image,\\n          srcX,\\n          srcY,\\n          this.frameWidth,\\n          this.frameHeight,\\n          x,\\n          y,\\n          destWidth,\\n          destHeight\\n        );\\n      }\\n      ctx.restore();\\n    } else {\\n      ctx.fillStyle = this.colorFallback;\\n      ctx.beginPath();\\n      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\\n      ctx.fill();\\n    }\\n  }\\n}\\n\\nclass Particle {\\n  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\\n    this.position = new Vector2(x, y);\\n    this.velocity = new Vector2(vx, vy);\\n    this.lifetime = lifetime;\\n    this.remaining = lifetime;\\n    this.color = color;\\n    this.type = type;\\n    this.size = type === 'explosion' ? 10 : 4;\\n  }\\n\\n  update(dt) {\\n    this.remaining -= dt;\\n    if (this.type === 'blood' || this.type === 'spark') {\\n      this.velocity.y += 30 * dt;\\n    }\\n    this.position.add(this.velocity.clone().scale(dt));\\n  }\\n\\n  draw(ctx) {\\n    if (this.remaining <= 0) {\\n      return;\\n    }\\n    const alpha = Math.max(this.remaining / this.lifetime, 0);\\n    ctx.save();\\n    ctx.globalAlpha = alpha;\\n    if (this.type === 'glow') {\\n      const gradient = ctx.createRadialGradient(\\n        this.position.x,\\n        this.position.y,\\n        0,\\n        this.position.x,\\n        this.position.y,\\n        this.size * 2\\n      );\\n      gradient.addColorStop(0, this.color);\\n      gradient.addColorStop(1, 'transparent');\\n      ctx.fillStyle = gradient;\\n      ctx.beginPath();\\n      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\\n      ctx.fill();\\n    } else {\\n      ctx.fillStyle = this.color;\\n      ctx.beginPath();\\n      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\\n      ctx.fill();\\n    }\\n    ctx.restore();\\n  }\\n}\\n\\nclass Projectile {\\n  constructor(config) {\\n    this.position = config.position.clone();\\n    this.velocity = config.velocity.clone();\\n    this.damage = config.damage;\\n    this.range = config.range;\\n    this.traveled = 0;\\n    this.radius = config.radius || 6;\\n    this.pierce = config.pierce || 1;\\n    this.owner = config.owner;\\n    this.lifesteal = config.lifesteal || 0;\\n    this.color = config.color || '#ffffff';\\n  }\\n\\n  update(dt) {\\n    const movement = this.velocity.clone().scale(dt);\\n    this.position.add(movement);\\n    this.traveled += movement.length();\\n  }\\n\\n  isExpired() {\\n    return this.traveled >= this.range;\\n  }\\n\\n  draw(ctx) {\\n    ctx.fillStyle = this.color;\\n    ctx.beginPath();\\n    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nclass Soul {\\n  constructor(x, y, type) {\\n    this.position = new Vector2(x, y);\\n    this.type = type;\\n    this.radius = 8;\\n    this.floatTimer = 0;\\n    this.collected = false;\\n  }\\n\\n  update(dt, player) {\\n    this.floatTimer += dt;\\n    const bob = Math.sin(this.floatTimer * 3) * 2;\\n    if (player && player.position.distance(this.position) < 25) {\\n      this.collected = true;\\n      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\\n      if (SOUL_TYPES[this.type].essence) {\\n        grantEssence(SOUL_TYPES[this.type].essence);\\n      }\\n    }\\n    this.renderOffset = bob;\\n  }\\n\\n  draw(ctx) {\\n    ctx.fillStyle = SOUL_TYPES[this.type].color;\\n    ctx.beginPath();\\n    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nclass Weapon {\\n  constructor(name, config) {\\n    this.name = name;\\n    this.damage = config.damage;\\n    this.fireRate = config.fireRate || 1;\\n    this.range = config.range || 100;\\n    this.type = config.type;\\n    this.cost = config.cost || 0;\\n    this.manual = config.manual || false;\\n    this.cooldown = 0;\\n    this.execute = config.execute;\\n    this.lifesteal = config.lifesteal || 0;\\n    this.extra = config.extra || {};\\n  }\\n\\n  update(dt, player, enemies) {\\n    if (this.manual) {\\n      return;\\n    }\\n    this.cooldown -= dt;\\n    if (this.cooldown <= 0) {\\n      const fired = this.execute(player, enemies, this);\\n      if (fired) {\\n        this.cooldown = 1 / this.fireRate;\\n      }\\n    }\\n  }\\n\\n  trigger(player, enemies) {\\n    return this.execute(player, enemies, this);\\n  }\\n}\\n\\nclass Enemy {\\n  constructor(type, x, y, isBoss = false) {\\n    this.type = type;\\n    this.isBoss = isBoss;\\n    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\\n    this.maxHealth = this.definition.health;\\n    this.health = this.maxHealth;\\n    this.damage = this.definition.damage;\\n    this.speed = this.definition.speed;\\n    this.position = new Vector2(x, y);\\n    this.velocity = new Vector2();\\n    this.alive = true;\\n    this.state = 'idle';\\n    this.deathTimer = 0;\\n    this.sprite = getSprite(type, this.definition.spriteSize || 48);\\n    this.sprite.colorFallback = this.definition.color;\\n  }\\n\\n  update(dt, player, multiplier) {\\n    if (!this.alive) {\\n      this.deathTimer += dt;\\n      this.sprite.update(dt, 'death');\\n      return;\\n    }\\n    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\\n    const distance = Math.max(toPlayer.length(), 0.0001);\\n    const direction = toPlayer.clone().scale(1 / distance);\\n    const effectiveSpeed = this.speed * multiplier;\\n    if (this.type === 'wraith') {\\n      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\\n      direction.add(swirl).normalize();\\n    }\\n    this.velocity = direction.clone().scale(effectiveSpeed);\\n    this.position.add(this.velocity.clone().scale(dt));\\n    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\\n  }\\n\\n  takeDamage(amount) {\\n    if (!this.alive) {\\n      return false;\\n    }\\n    this.health -= amount;\\n    if (this.health <= 0) {\\n      this.alive = false;\\n      this.state = 'death';\\n      return true;\\n    }\\n    this.state = 'hit';\\n    return false;\\n  }\\n\\n  draw(ctx) {\\n    const size = this.definition.spriteSize || 48;\\n    const drawX = this.position.x - size * 0.5;\\n    const drawY = this.position.y - size * 0.5;\\n    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\\n    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\\n    if (this.alive) {\\n      ctx.fillStyle = '#222';\\n      ctx.fillRect(drawX, drawY - 10, size, 4);\\n      ctx.fillStyle = '#e63946';\\n      const hpRatio = Math.max(this.health / this.maxHealth, 0);\\n      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\\n    }\\n  }\\n}\\n\\nclass Player {\\n  constructor(character) {\\n    const def = CHARACTER_DEFS[character];\\n    this.character = character;\\n    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\\n    this.velocity = new Vector2();\\n    this.speed = def.speed;\\n    this.range = def.range;\\n    this.maxHealth = def.maxHealth;\\n    this.health = def.maxHealth;\\n    this.baseDamage = def.baseDamage;\\n    this.level = 1;\\n    this.experience = 0;\\n    this.nextLevelExp = 100;\\n    this.armor = def.armor || 0;\\n    this.sprite = getSprite(character, def.spriteSize);\\n    this.sprite.colorFallback = '#f5f3f4';\\n    this.state = 'idle';\\n    this.killStreak = 0;\\n    this.killStreakTimer = 0;\\n    this.killStreakActive = false;\\n    this.killStreakDuration = 5;\\n    this.weapons = [];\\n    this.manualWeapons = {};\\n    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();\\n    this.unlockWeapon('CursedBlade');\\n    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);\\n    this.sprite.refreshAnimation();\\n  }\\n\\n  unlockWeapon(name) {\\n    if (!WEAPON_CONFIGS[name]) {\\n      return;\\n    }\\n    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\\n    if (weapon.manual) {\\n      this.manualWeapons[name] = weapon;\\n    } else {\\n      this.weapons.push(weapon);\\n    }\\n  }\\n\\n  update(dt, state) {\\n    const keys = state.keys;\\n    const input = new Vector2(\\n      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\\n      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\\n    );\\n    if (input.length() > 0) {\\n      input.normalize();\\n      this.velocity = input.clone().scale(this.speed);\\n      this.state = 'run';\\n    } else {\\n      this.velocity = new Vector2();\\n      this.state = 'idle';\\n    }\\n    this.position.add(this.velocity.clone().scale(dt));\\n    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\\n    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\\n    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\\n    if (this.killStreakActive) {\\n      this.killStreakTimer -= dt;\\n      if (this.killStreakTimer <= 0) {\\n        this.killStreakActive = false;\\n        this.killStreak = 0;\\n      }\\n    }\\n    this.sprite.update(dt, this.state);\\n  }\\n\\n  takeDamage(amount) {\\n    if (this.character === 'rogue' && Math.random() < 0.1) {\\n      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\\n      return;\\n    }\\n    const mitigated = Math.max(amount - this.armor, 1);\\n    this.health -= mitigated;\\n    if (this.health <= 0) {\\n      this.health = 0;\\n      gameState.alive = false;\\n    }\\n  }\\n\\n  gainExperience(amount) {\\n    this.experience += amount;\\n    while (this.experience >= this.nextLevelExp) {\\n      this.experience -= this.nextLevelExp;\\n      this.level += 1;\\n      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\\n      this.maxHealth += 5;\\n      this.health = this.maxHealth;\\n      if (this.character === 'knight') {\\n        this.armor += 1;\\n      }\\n      if (this.level >= 3 && this.pendingUnlocks.length > 0) {\\n        const weaponName = this.pendingUnlocks.shift();\\n        if (weaponName) {\\n          this.unlockWeapon(weaponName);\\n        }\\n      }\\n    }\\n  }\\n\\n  registerKill() {\\n    this.killStreak += 1;\\n    if (this.character === 'rogue' && this.killStreak >= 5) {\\n      this.killStreakActive = true;\\n      this.killStreakTimer = this.killStreakDuration;\\n    }\\n  }\\n\\n  getDamageMultiplier() {\\n    let multiplier = 1 + (this.level - 1) * 0.05;\\n    if (this.killStreakActive) {\\n      multiplier += 0.15;\\n    }\\n    return multiplier;\\n  }\\n\\n  draw(ctx) {\\n    const size = CHARACTER_DEFS[this.character].spriteSize;\\n    const drawX = this.position.x - size * 0.5;\\n    const drawY = this.position.y - size * 0.5;\\n    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\\n    ctx.fillStyle = '#222';\\n    ctx.fillRect(drawX, drawY - 12, size, 5);\\n    ctx.fillStyle = '#7cf5ff';\\n    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\\n  }\\n}\\n\\nconst WEAPON_CONFIGS = {\\n  CursedBlade: {\\n    damage: 10,\\n    fireRate: 1,\\n    range: 100,\\n    type: 'cone',\\n    execute: (player, enemies, weapon) => {\\n      let hit = false;\\n      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) {\\n          return;\\n        }\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const angleToEnemy = Math.atan2(\\n            enemy.position.y - player.position.y,\\n            enemy.position.x - player.position.x\\n          );\\n          let delta = angleToEnemy - facingAngle;\\n          while (delta > Math.PI) delta -= Math.PI * 2;\\n          while (delta < -Math.PI) delta += Math.PI * 2;\\n          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            hit = hit || killed;\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n          }\\n        }\\n      });\\n      if (hit) {\\n        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\\n      }\\n      return true;\\n    }\\n  },\\n  ShatterburstAxe: {\\n    damage: 15,\\n    fireRate: 0.8,\\n    range: 60,\\n    type: 'aoe',\\n    execute: (player, enemies, weapon) => {\\n      let any = false;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        if (player.position.distance(enemy.position) <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          any = any || killed;\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          } else {\\n            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\\n            enemy.position.add(push);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\\n      return true;\\n    }\\n  },\\n  SoulreaverDagger: {\\n    damage: 5,\\n    fireRate: 2,\\n    range: 30,\\n    type: 'multi-hit',\\n    execute: (player, enemies, weapon) => {\\n      let target = null;\\n      let closest = Infinity;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance < closest && distance <= weapon.range) {\\n          closest = distance;\\n          target = enemy;\\n        }\\n      });\\n      if (!target) {\\n        return false;\\n      }\\n      for (let i = 0; i < 3; i += 1) {\\n        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\\n        if (killed) {\\n          handleEnemyDeath(target);\\n          break;\\n        }\\n        player.health = Math.min(\\n          player.maxHealth,\\n          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\\n        );\\n      }\\n      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\\n      return true;\\n    }\\n  },\\n  EternalHalberd: {\\n    damage: 25,\\n    fireRate: 0.5,\\n    range: 80,\\n    type: 'aoe',\\n    execute: (player, enemies, weapon) => {\\n      let hitAny = false;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          hitAny = hitAny || killed;\\n          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\\n          enemy.position.add(pull.scale(0.1));\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\\n      return true;\\n    }\\n  },\\n  ChaosOrb: {\\n    damage: 8,\\n    fireRate: 1.2,\\n    range: 300,\\n    type: 'projectile',\\n    execute: (player) => {\\n      const orbCount = 2 + Math.floor(Math.random() * 3);\\n      for (let i = 0; i < orbCount; i += 1) {\\n        const angle = Math.random() * Math.PI * 2;\\n        const velocity = Vector2.fromAngle(angle, 200);\\n        gameState.projectiles.push(\\n          new Projectile({\\n            position: player.position.clone(),\\n            velocity,\\n            damage: 8 * player.getDamageMultiplier(),\\n            range: 320,\\n            pierce: 3,\\n            owner: player,\\n            color: '#7bed9f'\\n          })\\n        );\\n      }\\n      return true;\\n    }\\n  },\\n  ReapersScythe: {\\n    damage: 20,\\n    fireRate: 0.8,\\n    range: 100,\\n    type: 'spin',\\n    execute: (player, enemies, weapon) => {\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const distance = player.position.distance(enemy.position);\\n        if (distance <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          } else {\\n            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\\n            enemy.position.add(pull);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\\n      return true;\\n    }\\n  },\\n  BloodmoonLance: {\\n    damage: 20,\\n    fireRate: 1,\\n    range: 400,\\n    type: 'beam',\\n    lifesteal: 0.5,\\n    execute: (player, enemies, weapon) => {\\n      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        const toEnemy = enemy.position.clone().subtract(player.position);\\n        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\\n        if (projection >= 0 && projection <= weapon.range) {\\n          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\\n          if (perpendicular <= 40) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n            player.health = Math.min(\\n              player.maxHealth,\\n              player.health + weapon.damage * weapon.lifesteal\\n            );\\n          }\\n        }\\n      });\\n      spawnParticleBurst(\\n        player.position.x + direction.x * 60,\\n        player.position.y + direction.y * 60,\\n        '#ff99c8',\\n        'glow',\\n        14\\n      );\\n      return true;\\n    }\\n  },\\n  GodsayerSword: {\\n    damage: 100,\\n    fireRate: 1,\\n    range: 150,\\n    type: 'manual',\\n    manual: true,\\n    cost: 1,\\n    execute: (player, enemies, weapon) => {\\n      if (gameState.weaponCharges < weapon.cost) {\\n        return false;\\n      }\\n      gameState.weaponCharges -= weapon.cost;\\n      enemies.forEach((enemy) => {\\n        if (!enemy.alive) return;\\n        if (player.position.distance(enemy.position) <= weapon.range) {\\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n          if (killed) {\\n            handleEnemyDeath(enemy);\\n          }\\n        }\\n      });\\n      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\\n      triggerScreenShake();\\n      return true;\\n    }\\n  },\\n  VoidSummoner: {\\n    damage: 15,\\n    fireRate: 0.125,\\n    range: 200,\\n    cost: 2,\\n    type: 'summon',\\n    execute: (player, enemies, weapon) => {\\n      if (gameState.weaponCharges < weapon.cost) {\\n        return false;\\n      }\\n      gameState.weaponCharges -= weapon.cost;\\n      for (let i = 0; i < 3; i += 1) {\\n        const angle = (Math.PI * 2 * i) / 3;\\n        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\\n        enemies.forEach((enemy) => {\\n          if (!enemy.alive) return;\\n          if (summonPos.distance(enemy.position) <= 70) {\\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\\n            if (killed) {\\n              handleEnemyDeath(enemy);\\n            }\\n          }\\n        });\\n        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\\n      }\\n      return true;\\n    }\\n  }\\n};\\n\\nconst gameState = {\\n  canvas: null,\\n  ctx: null,\\n  player: null,\\n  enemies: [],\\n  souls: [],\\n  particles: [],\\n  projectiles: [],\\n  alive: false,\\n  keys: { w: false, a: false, s: false, d: false },\\n  gameTime: 0,\\n  waveTimer: 0,\\n  waveNumber: 0,\\n  bossTimer: 0,\\n  bossIndex: 0,\\n  enemiesKilled: 0,\\n  difficultyMultiplier: 1,\\n  weaponCharges: 0,\\n  essenceCollected: 0,\\n  pendingGodsayer: false,\\n  screenShake: 0,\\n  lastTimestamp: performance.now()\\n};\\n\\nfunction ensureCanvas() {\\n  if (!gameState.canvas) {\\n    gameState.canvas = document.getElementById('gameCanvas');\\n    if (gameState.canvas) {\\n      gameState.ctx = gameState.canvas.getContext('2d');\\n    }\\n  }\\n}\\n\\nfunction initGame(character = 'knight') {\\n  ensureCanvas();\\n  gameState.player = new Player(character);\\n  gameState.enemies = [];\\n  gameState.souls = [];\\n  gameState.particles = [];\\n  gameState.projectiles = [];\\n  gameState.gameTime = 0;\\n  gameState.waveTimer = 0;\\n  gameState.waveNumber = 0;\\n  gameState.bossTimer = 0;\\n  gameState.enemiesKilled = 0;\\n  gameState.weaponCharges = 0;\\n  gameState.essenceCollected = 0;\\n  gameState.alive = true;\\n  gameState.screenShake = 0;\\n}\\n\\nfunction spawnWave() {\\n  if (!gameState.player) {\\n    return;\\n  }\\n  const count = 5 + gameState.waveNumber * 2;\\n  for (let i = 0; i < count; i += 1) {\\n    const isElite = Math.random() < 0.2;\\n    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\\n    const type = pool[Math.floor(Math.random() * pool.length)];\\n    const angle = Math.random() * Math.PI * 2;\\n    const spawnRadius = 150 + Math.random() * 100;\\n    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\\n    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\\n    gameState.enemies.push(new Enemy(type, posX, posY));\\n  }\\n  gameState.waveNumber += 1;\\n  gameState.waveTimer = 0;\\n}\\n\\nfunction spawnBoss() {\\n  const bossKeys = Object.keys(BOSS_DEFS);\\n  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\\n  gameState.bossIndex += 1;\\n  const edge = Math.floor(Math.random() * 4);\\n  let x = 0;\\n  let y = 0;\\n  if (edge === 0) {\\n    x = Math.random() * CANVAS_WIDTH;\\n    y = -50;\\n  } else if (edge === 1) {\\n    x = CANVAS_WIDTH + 50;\\n    y = Math.random() * CANVAS_HEIGHT;\\n  } else if (edge === 2) {\\n    x = Math.random() * CANVAS_WIDTH;\\n    y = CANVAS_HEIGHT + 50;\\n  } else {\\n    x = -50;\\n    y = Math.random() * CANVAS_HEIGHT;\\n  }\\n  const boss = new Enemy(bossName, x, y, true);\\n  gameState.enemies.push(boss);\\n  gameState.bossTimer = 0;\\n  triggerScreenShake(20);\\n}\\n\\nfunction grantEssence(amount) {\\n  gameState.essenceCollected += amount;\\n  if (gameState.essenceCollected >= 5) {\\n    const charges = Math.floor(gameState.essenceCollected / 5);\\n    gameState.weaponCharges += charges;\\n    gameState.essenceCollected -= charges * 5;\\n  }\\n}\\n\\nfunction handleEnemyDeath(enemy) {\\n  if (!enemy) {\\n    return;\\n  }\\n  gameState.enemiesKilled += 1;\\n  if (gameState.player) {\\n    gameState.player.registerKill();\\n  }\\n  dropSoul(enemy);\\n  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\\n}\\n\\nfunction dropSoul(enemy) {\\n  if (enemy.isBoss) {\\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\\n    return;\\n  }\\n  if (ENEMY_DEFS[enemy.type].elite) {\\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\\n    if (Math.random() < 0.4) {\\n      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\\n    }\\n  } else {\\n    if (Math.random() < 0.95) {\\n      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\\n    }\\n    if (Math.random() < 0.05) {\\n      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\\n    }\\n  }\\n}\\n\\nfunction spawnParticleBurst(x, y, color, type, count) {\\n  for (let i = 0; i < count; i += 1) {\\n    const angle = Math.random() * Math.PI * 2;\\n    const speed = 40 + Math.random() * 120;\\n    const vx = Math.cos(angle) * speed;\\n    const vy = Math.sin(angle) * speed;\\n    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\\n    gameState.particles.push(particle);\\n  }\\n}\\n\\nfunction triggerScreenShake(intensity = 10) {\\n  gameState.screenShake = Math.max(gameState.screenShake, intensity);\\n}\\n\\nfunction updateProjectiles(dt) {\\n  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\\n    const projectile = gameState.projectiles[i];\\n    projectile.update(dt);\\n    let removed = false;\\n    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\\n      const enemy = gameState.enemies[j];\\n      if (!enemy.alive) continue;\\n      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\\n        const killed = enemy.takeDamage(projectile.damage);\\n        if (killed) {\\n          handleEnemyDeath(enemy);\\n        }\\n        projectile.pierce -= 1;\\n        if (projectile.lifesteal && gameState.player) {\\n          gameState.player.health = Math.min(\\n            gameState.player.maxHealth,\\n            gameState.player.health + projectile.damage * projectile.lifesteal\\n          );\\n        }\\n        if (projectile.pierce <= 0) {\\n          removed = true;\\n          break;\\n        }\\n      }\\n    }\\n    if (projectile.isExpired() || removed) {\\n      gameState.projectiles.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateSouls(dt) {\\n  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\\n    const soul = gameState.souls[i];\\n    soul.update(dt, gameState.player);\\n    if (soul.collected) {\\n      gameState.souls.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateParticles(dt) {\\n  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\\n    const particle = gameState.particles[i];\\n    particle.update(dt);\\n    if (particle.remaining <= 0) {\\n      gameState.particles.splice(i, 1);\\n    }\\n  }\\n}\\n\\nfunction updateEnemies(dt) {\\n  const player = gameState.player;\\n  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\\n    const enemy = gameState.enemies[i];\\n    enemy.update(dt, player, gameState.difficultyMultiplier);\\n    if (!enemy.alive && enemy.deathTimer > 1.5) {\\n      gameState.enemies.splice(i, 1);\\n    }\\n    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\\n      const damage = enemy.damage;\\n      player.takeDamage(damage);\\n      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\\n    }\\n  }\\n}\\n\\nfunction triggerGodsayerSword() {\\n  if (!gameState.player) {\\n    return false;\\n  }\\n  const weapon = gameState.player.manualWeapons.GodsayerSword;\\n  if (!weapon) {\\n    return false;\\n  }\\n  return weapon.trigger(gameState.player, gameState.enemies);\\n}\\n\\nfunction gameLoop(dt) {\\n  ensureCanvas();\\n  if (!gameState.ctx) {\\n    return;\\n  }\\n  if (gameState.player && gameState.alive) {\\n    gameState.gameTime += dt;\\n    gameState.waveTimer += dt;\\n    gameState.bossTimer += dt;\\n    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\\n    gameState.player.update(dt, gameState);\\n    updateEnemies(dt);\\n    updateProjectiles(dt);\\n    updateSouls(dt);\\n    updateParticles(dt);\\n    if (gameState.waveTimer >= 30) {\\n      spawnWave();\\n    }\\n    if (gameState.bossTimer >= 120) {\\n      spawnBoss();\\n    }\\n    if (gameState.player.health <= 0) {\\n      gameState.alive = false;\\n    }\\n  }\\n  drawGame();\\n  notifyHUD();\\n}\\n\\nfunction drawGame() {\\n  const ctx = gameState.ctx;\\n  if (!ctx) {\\n    return;\\n  }\\n  ctx.save();\\n  if (gameState.screenShake > 0) {\\n    ctx.translate(\\n      (Math.random() - 0.5) * gameState.screenShake,\\n      (Math.random() - 0.5) * gameState.screenShake\\n    );\\n    gameState.screenShake *= 0.9;\\n  }\\n  drawBackground(ctx);\\n  gameState.souls.forEach((soul) => soul.draw(ctx));\\n  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\\n  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\\n  if (gameState.player) {\\n    gameState.player.draw(ctx);\\n  }\\n  gameState.particles.forEach((particle) => particle.draw(ctx));\\n  drawHUDOverlay(ctx);\\n  ctx.restore();\\n}\\n\\nfunction drawBackground(ctx) {\\n  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\\n  gradient.addColorStop(0, '#1a0327');\\n  gradient.addColorStop(0.5, '#1f1f49');\\n  gradient.addColorStop(1, '#040308');\\n  ctx.fillStyle = gradient;\\n  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\\n  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\\n  for (let i = 0; i < 8; i += 1) {\\n    const angle = (Math.PI * 2 * i) / 8;\\n    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\\n    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\\n    ctx.beginPath();\\n    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\\n    ctx.stroke();\\n  }\\n  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\\n  ctx.beginPath();\\n  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\\n  ctx.stroke();\\n}\\n\\nfunction drawHUDOverlay(ctx) {\\n  if (!gameState.player) {\\n    return;\\n  }\\n  ctx.fillStyle = 'rgba(0,0,0,0.35)';\\n  ctx.fillRect(15, 15, 220, 110);\\n  ctx.fillStyle = '#ffffff';\\n  ctx.font = '14px \\\"Segoe UI\\\", sans-serif';\\n  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\\n  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\\n  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\\n  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\\n  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\\n  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\\n}\\n\\nfunction notifyHUD() {\\n  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\\n    window.updateHUD(gameState);\\n  }\\n  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\\n    window.showDeathScreen(gameState);\\n  }\\n}\\n\\nfunction animationLoop(timestamp) {\\n  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\\n  gameState.lastTimestamp = timestamp;\\n  gameLoop(dt || TARGET_DELTA);\\n  window.requestAnimationFrame(animationLoop);\\n}\\n\\nwindow.requestAnimationFrame(animationLoop);\\n\\nfunction setKeyState(key, isDown) {\\n  if (gameState.keys[key] !== undefined) {\\n    gameState.keys[key] = isDown;\\n  }\\n}\\n\\nwindow.initGame = initGame;\\nwindow.triggerGodsayerSword = triggerGodsayerSword;\\nwindow.setKeyState = setKeyState;\\nwindow.gameState = gameState;\\nwindow.spawnWave = spawnWave;\\nwindow.spawnBoss = spawnBoss;\\nwindow.grantEssence = grantEssence;\\nwindow.handleEnemyDeath = handleEnemyDeath;\\nwindow.triggerScreenShake = triggerScreenShake;\\n\\n</content>\\n<metadata>\\nTotal lines: 1230, returned complete file\\n</metadata>\"}], \"action_name\": \"ToolReadFile\", \"message\": \"Action 'ToolReadFile' completed successfully\"}", "rejected": false}
</TOOL_RESULT>

```javascript
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    }

    clone() {
    return new Vector2(this.x, this.y);
    }

    add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
    }

    subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
    }

    scale(s) {
    this.x *= s;
    this.y *= s;
    return this;
    }

    length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    normalize() {
    const len = this.length() || 1;
    this.x /= len;
    this.y /= len;
    return this;
    }

    distance(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
    }

    angle(other) {
    return Math.atan2(other.y - this.y, other.x - this.x);
    }

    static fromAngle(angle, magnitude = 1) {
    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);
    }
}

const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 600;
const TARGET_DELTA = 1 / 60;
const DEG_TO_RAD = Math.PI / 180;
const DEFAULT_ANIMATION = {
  animations: {
    idle: { frameCount: 1, frameTime: 1, loop: true },
    run: { frameCount: 1, frameTime: 1, loop: true },
    attack: { frameCount: 1, frameTime: 1, loop: false },
    hit: { frameCount: 1, frameTime: 1, loop: false },
    death: { frameCount: 1, frameTime: 1, loop: false }
    }
};

const CHARACTER_DEFS = {
  knight: {
    maxHealth: 100,
    baseDamage: 12,
    range: 110,
    speed: 200,
    armor: 5,
    spriteSize: 48
    },
  witch: {
    maxHealth: 70,
    baseDamage: 8,
    range: 140,
    speed: 180,
    armor: 2,
    spriteSize: 48
    },
  rogue: {
    maxHealth: 85,
    baseDamage: 10,
    range: 90,
    speed: 250,
    armor: 3,
    spriteSize: 48,
    dodgeChance: 0.1
    }
};

const ENEMY_DEFS = {
  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },
  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },
  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },
  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },
  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },
  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },
  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }
};

const BOSS_DEFS = {
  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },
  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },
  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }
};

const SOUL_TYPES = {
  ethereal: { xp: 10, color: '#f3f6ff' },
  essence: { xp: 0, color: '#ffd95a', essence: 1 },
  corrupted: { xp: 20, color: '#b21f35' },
  cursed: { xp: 50, color: '#0d0d0d' }
};

const LEVEL_WEAPON_UNLOCK = [
    'ShatterburstAxe',
  'SoulreaverDagger',
  'EternalHalberd',
  'ChaosOrb',
  'ReapersScythe',
  'BloodmoonLance',
  'VoidSummoner'
];

const spriteCache = {};
const animationCache = {};

function getAnimationPath(name) {
  return `animations/${name}.json`;
}

function getSprite(name, spriteSize = 48) {
  if (spriteCache[name]) {
    return spriteCache[name];
    }
    const sprite = new Sprite(
    name,
    `sprites/${name}.png`,
    spriteSize,
    spriteSize,
    getAnimationPath(name)
    );
    spriteCache[name] = sprite;
    return sprite;
}

function loadAnimationData(name) {
  if (animationCache[name]) {
    return animationCache[name];
    }
    animationCache[name] = DEFAULT_ANIMATION;
    fetch(getAnimationPath(name))
    .then((resp) => resp.json())
    .then((data) => {
      animationCache[name] = data.animations ? data : { animations: data };
    })
    .catch(() => {
      animationCache[name] = DEFAULT_ANIMATION;
    });
    return animationCache[name];
}

class Sprite {
  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {
    this.name = name;
    this.image = new Image();
    this.image.src = imageUrl;
    this.imageLoaded = false;
    this.imageFailed = false;
    this.image.onload = () => {
      this.imageLoaded = true;
    };
    this.image.onerror = () => {
      this.imageFailed = true;
    };
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;
    this.currentState = 'idle';
    this.animationTime = 0;
    this.frameIndex = 0;
    this.colorFallback = '#ffffff';
    this.animationPath = animationPath;
    this.refreshAnimation();
    }

    refreshAnimation() {
    fetch(this.animationPath)
        .then((resp) => resp.json())
        .then((data) => {
        this.animationData = data.animations ? data : { animations: data };
        })
        .catch(() => {
        this.animationData = DEFAULT_ANIMATION;
        });
    }

    update(dt, desiredState = 'idle') {
    if (this.currentState !== desiredState) {
      this.currentState = desiredState;
        this.animationTime = 0;
    } else {
      this.animationTime += dt;
    }
    const animSpec = this.getAnimationSpec(this.currentState);
    const totalDuration = animSpec.frameCount * animSpec.frameTime;
    if (animSpec.loop) {
      this.animationTime = this.animationTime % (totalDuration || 1);
    } else if (this.animationTime > totalDuration) {
      this.animationTime = totalDuration - animSpec.frameTime;
    }
    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;
    }

    getAnimationSpec(state) {
    const data = this.animationData.animations || this.animationData;
    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;
    }

    draw(ctx, x, y, scale = 1, flipX = false) {
    if (this.imageLoaded && !this.imageFailed) {
      const animSpec = this.getAnimationSpec(this.currentState);
        const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;
        const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;
        const srcY = 0;
        const destWidth = this.frameWidth * scale;
        const destHeight = this.frameHeight * scale;
        ctx.save();
        if (flipX) {
        ctx.translate(x + destWidth, y);
        ctx.scale(-1, 1);
        ctx.drawImage(
          this.image,
          srcX,
          srcY,
          this.frameWidth,
          this.frameHeight,
          0,
          0,
          destWidth,
          destHeight
        );
        } else {
        ctx.drawImage(
          this.image,
          srcX,
          srcY,
          this.frameWidth,
          this.frameHeight,
          x,
          y,
          destWidth,
          destHeight
        );
        }
        ctx.restore();
    } else {
      ctx.fillStyle = this.colorFallback;
        ctx.beginPath();
        ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
    }
}

class Particle {
  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {
    this.position = new Vector2(x, y);
    this.velocity = new Vector2(vx, vy);
    this.lifetime = lifetime;
    this.remaining = lifetime;
    this.color = color;
    this.type = type;
    this.size = type === 'explosion' ? 10 : 4;
    }

    update(dt) {
    this.remaining -= dt;
    if (this.type === 'blood' || this.type === 'spark') {
      this.velocity.y += 30 * dt;
    }
    this.position.add(this.velocity.clone().scale(dt));
    }

    draw(ctx) {
    if (this.remaining <= 0) {
      return;
    }
    const alpha = Math.max(this.remaining / this.lifetime, 0);
    ctx.save();
    ctx.globalAlpha = alpha;
    if (this.type === 'glow') {
      const gradient = ctx.createRadialGradient(
        this.position.x,
        this.position.y,
        0,
        this.position.x,
        this.position.y,
        this.size * 2
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
      ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
    }
}

class Projectile {
  constructor(config) {
    this.position = config.position.clone();
    this.velocity = config.velocity.clone();
    this.damage = config.damage;
    this.range = config.range;
    this.traveled = 0;
    this.radius = config.radius || 6;
    this.pierce = config.pierce || 1;
    this.owner = config.owner;
    this.lifesteal = config.lifesteal || 0;
    this.color = config.color || '#ffffff';
    }

    update(dt) {
    const movement = this.velocity.clone().scale(dt);
    this.position.add(movement);
    this.traveled += movement.length();
    }

    isExpired() {
    return this.traveled >= this.range;
    }

    draw(ctx) {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    }
}

class Soul {
  constructor(x, y, type) {
    this.position = new Vector2(x, y);
    this.type = type;
    this.radius = 8;
    this.floatTimer = 0;
    this.collected = false;
    }

    update(dt, player) {
    this.floatTimer += dt;
    const bob = Math.sin(this.floatTimer * 3) * 2;
    if (player && player.position.distance(this.position) < 25) {
      this.collected = true;
        player.gainExperience(SOUL_TYPES[this.type].xp || 0);
        if (SOUL_TYPES[this.type].essence) {
        grantEssence(SOUL_TYPES[this.type].essence);
        }
    }
    this.renderOffset = bob;
    }

    draw(ctx) {
    ctx.fillStyle = SOUL_TYPES[this.type].color;
    ctx.beginPath();
    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);
    ctx.fill();
    }
}

class Weapon {
  constructor(name, config) {
    this.name = name;
    this.damage = config.damage;
    this.fireRate = config.fireRate || 1;
    this.range = config.range || 100;
    this.type = config.type;
    this.cost = config.cost || 0;
    this.manual = config.manual || false;
    this.cooldown = 0;
    this.execute = config.execute;
    this.lifesteal = config.lifesteal || 0;
    this.extra = config.extra || {};
    }

    update(dt, player, enemies) {
    if (this.manual) {
      return;
    }
    this.cooldown -= dt;
    if (this.cooldown <= 0) {
      const fired = this.execute(player, enemies, this);
        if (fired) {
        this.cooldown = 1 / this.fireRate;
        }
    }
    }

    trigger(player, enemies) {
    return this.execute(player, enemies, this);
    }
}

class Enemy {
  constructor(type, x, y, isBoss = false) {
    this.type = type;
    this.isBoss = isBoss;
    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];
    this.maxHealth = this.definition.health;
    this.health = this.maxHealth;
    this.damage = this.definition.damage;
    this.speed = this.definition.speed;
    this.position = new Vector2(x, y);
    this.velocity = new Vector2();
    this.alive = true;
    this.state = 'idle';
    this.deathTimer = 0;
    this.sprite = getSprite(type, this.definition.spriteSize || 48);
    this.sprite.colorFallback = this.definition.color;
    }

    update(dt, player, multiplier) {
    if (!this.alive) {
      this.deathTimer += dt;
        this.sprite.update(dt, 'death');
        return;
    }
    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);
    const distance = Math.max(toPlayer.length(), 0.0001);
    const direction = toPlayer.clone().scale(1 / distance);
    const effectiveSpeed = this.speed * multiplier;
    if (this.type === 'wraith') {
      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);
        direction.add(swirl).normalize();
    }
    this.velocity = direction.clone().scale(effectiveSpeed);
    this.position.add(this.velocity.clone().scale(dt));
    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');
    }

    takeDamage(amount) {
    if (!this.alive) {
      return false;
    }
    this.health -= amount;
    if (this.health <= 0) {
      this.alive = false;
        this.state = 'death';
        return true;
    }
    this.state = 'hit';
    return false;
    }

    draw(ctx) {
    const size = this.definition.spriteSize || 48;
    const drawX = this.position.x - size * 0.5;
    const drawY = this.position.y - size * 0.5;
    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');
    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);
    if (this.alive) {
      ctx.fillStyle = '#222';
        ctx.fillRect(drawX, drawY - 10, size, 4);
        ctx.fillStyle = '#e63946';
        const hpRatio = Math.max(this.health / this.maxHealth, 0);
        ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);
    }
    }
}

class Player {
  constructor(character) {
    const def = CHARACTER_DEFS[character];
    this.character = character;
    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
    this.velocity = new Vector2();
    this.speed = def.speed;
    this.range = def.range;
    this.maxHealth = def.maxHealth;
    this.health = def.maxHealth;
    this.baseDamage = def.baseDamage;
    this.level = 1;
    this.experience = 0;
    this.nextLevelExp = 100;
    this.armor = def.armor || 0;
    this.sprite = getSprite(character, def.spriteSize);
    this.sprite.colorFallback = '#f5f3f4';
    this.state = 'idle';
    this.killStreak = 0;
    this.killStreakTimer = 0;
    this.killStreakActive = false;
    this.killStreakDuration = 5;
    this.weapons = [];
    this.manualWeapons = {};
    this.pendingUnlocks = LEVEL_WEAPON_UNLOCK.slice();
    this.unlockWeapon('CursedBlade');
    this.manualWeapons.GodsayerSword = new Weapon('GodsayerSword', WEAPON_CONFIGS.GodsayerSword);
    this.sprite.refreshAnimation();
    }

    unlockWeapon(name) {
    if (!WEAPON_CONFIGS[name]) {
      return;
    }
    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);
    if (weapon.manual) {
      this.manualWeapons[name] = weapon;
    } else {
      this.weapons.push(weapon);
    }
    }

    update(dt, state) {
    const keys = state.keys;
    const input = new Vector2(
      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),
      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)
    );
    if (input.length() > 0) {
      input.normalize();
        this.velocity = input.clone().scale(this.speed);
        this.state = 'run';
    } else {
      this.velocity = new Vector2();
        this.state = 'idle';
    }
    this.position.add(this.velocity.clone().scale(dt));
    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));
    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));
    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));
    if (this.killStreakActive) {
      this.killStreakTimer -= dt;
        if (this.killStreakTimer <= 0) {
        this.killStreakActive = false;
        this.killStreak = 0;
        }
    }
    this.sprite.update(dt, this.state);
    }

    takeDamage(amount) {
    if (this.character === 'rogue' && Math.random() < 0.1) {
      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);
        return;
    }
    const mitigated = Math.max(amount - this.armor, 1);
    this.health -= mitigated;
    if (this.health <= 0) {
      this.health = 0;
        gameState.alive = false;
    }
    }

    gainExperience(amount) {
    this.experience += amount;
    while (this.experience >= this.nextLevelExp) {
      this.experience -= this.nextLevelExp;
        this.level += 1;
        this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);
        this.maxHealth += 5;
        this.health = this.maxHealth;
        if (this.character === 'knight') {
        this.armor += 1;
        }
        if (this.level >= 3 && this.pendingUnlocks.length > 0) {
        const weaponName = this.pendingUnlocks.shift();
        if (weaponName) {
          this.unlockWeapon(weaponName);
        }
        }
    }
    }

    registerKill() {
    this.killStreak += 1;
    if (this.character === 'rogue' && this.killStreak >= 5) {
      this.killStreakActive = true;
        this.killStreakTimer = this.killStreakDuration;
    }
    }

    getDamageMultiplier() {
    let multiplier = 1 + (this.level - 1) * 0.05;
    if (this.killStreakActive) {
      multiplier += 0.15;
    }
    return multiplier;
    }

    draw(ctx) {
    const size = CHARACTER_DEFS[this.character].spriteSize;
    const drawX = this.position.x - size * 0.5;
    const drawY = this.position.y - size * 0.5;
    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);
    ctx.fillStyle = '#222';
    ctx.fillRect(drawX, drawY - 12, size, 5);
    ctx.fillStyle = '#7cf5ff';
    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);
    }
}

const WEAPON_CONFIGS = {
  CursedBlade: {
    damage: 10,
    fireRate: 1,
    range: 100,
    type: 'cone',
    execute: (player, enemies, weapon) => {
      let hit = false;
        const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;
        enemies.forEach((enemy) => {
        if (!enemy.alive) {
          return;
        }
        const distance = player.position.distance(enemy.position);
        if (distance <= weapon.range) {
          const angleToEnemy = Math.atan2(
            enemy.position.y - player.position.y,
            enemy.position.x - player.position.x
            );
            let delta = angleToEnemy - facingAngle;
            while (delta > Math.PI) delta -= Math.PI * 2;
            while (delta < -Math.PI) delta += Math.PI * 2;
            if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {
            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            hit = hit || killed;
            if (killed) {
              handleEnemyDeath(enemy);
            }
            }
        }
        });
        if (hit) {
        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);
        }
        return true;
    }
    },
  ShatterburstAxe: {
    damage: 15,
    fireRate: 0.8,
    range: 60,
    type: 'aoe',
    execute: (player, enemies, weapon) => {
      let any = false;
        enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        if (player.position.distance(enemy.position) <= weapon.range) {
          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            any = any || killed;
            if (killed) {
            handleEnemyDeath(enemy);
            } else {
            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);
            enemy.position.add(push);
            }
        }
        });
        spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);
        return true;
    }
    },
  SoulreaverDagger: {
    damage: 5,
    fireRate: 2,
    range: 30,
    type: 'multi-hit',
    execute: (player, enemies, weapon) => {
      let target = null;
        let closest = Infinity;
        enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        const distance = player.position.distance(enemy.position);
        if (distance < closest && distance <= weapon.range) {
          closest = distance;
            target = enemy;
        }
        });
        if (!target) {
        return false;
        }
        for (let i = 0; i < 3; i += 1) {
        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());
        if (killed) {
          handleEnemyDeath(target);
            break;
        }
        player.health = Math.min(
          player.maxHealth,
          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()
        );
        }
        spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);
        return true;
    }
    },
  EternalHalberd: {
    damage: 25,
    fireRate: 0.5,
    range: 80,
    type: 'aoe',
    execute: (player, enemies, weapon) => {
      let hitAny = false;
        enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        const distance = player.position.distance(enemy.position);
        if (distance <= weapon.range) {
          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            hitAny = hitAny || killed;
            const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);
            enemy.position.add(pull.scale(0.1));
            if (killed) {
            handleEnemyDeath(enemy);
            }
        }
        });
        spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);
        return true;
    }
    },
  ChaosOrb: {
    damage: 8,
    fireRate: 1.2,
    range: 300,
    type: 'projectile',
    execute: (player) => {
      const orbCount = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < orbCount; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const velocity = Vector2.fromAngle(angle, 200);
        gameState.projectiles.push(
          new Projectile({
            position: player.position.clone(),
            velocity,
            damage: 8 * player.getDamageMultiplier(),
            range: 320,
            pierce: 3,
            owner: player,
            color: '#7bed9f'
            })
        );
        }
        return true;
    }
    },
  ReapersScythe: {
    damage: 20,
    fireRate: 0.8,
    range: 100,
    type: 'spin',
    execute: (player, enemies, weapon) => {
      enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        const distance = player.position.distance(enemy.position);
        if (distance <= weapon.range) {
          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            if (killed) {
            handleEnemyDeath(enemy);
            } else {
            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);
            enemy.position.add(pull);
            }
        }
        });
        spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);
        return true;
    }
    },
  BloodmoonLance: {
    damage: 20,
    fireRate: 1,
    range: 400,
    type: 'beam',
    lifesteal: 0.5,
    execute: (player, enemies, weapon) => {
      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);
        enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        const toEnemy = enemy.position.clone().subtract(player.position);
        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;
        if (projection >= 0 && projection <= weapon.range) {
          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);
            if (perpendicular <= 40) {
            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            if (killed) {
              handleEnemyDeath(enemy);
            }
            player.health = Math.min(
              player.maxHealth,
              player.health + weapon.damage * weapon.lifesteal
            );
            }
        }
        });
        spawnParticleBurst(
        player.position.x + direction.x * 60,
        player.position.y + direction.y * 60,
        '#ff99c8',
        'glow',
        14
        );
        return true;
    }
    },
  GodsayerSword: {
    damage: 100,
    fireRate: 1,
    range: 150,
    type: 'manual',
    manual: true,
    cost: 1,
    execute: (player, enemies, weapon) => {
      if (gameState.weaponCharges < weapon.cost) {
        return false;
        }
        gameState.weaponCharges -= weapon.cost;
        enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        if (player.position.distance(enemy.position) <= weapon.range) {
          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            if (killed) {
            handleEnemyDeath(enemy);
            }
        }
        });
        spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);
        triggerScreenShake();
        return true;
    }
    },
  VoidSummoner: {
    damage: 15,
    fireRate: 0.125,
    range: 200,
    cost: 2,
    type: 'summon',
    execute: (player, enemies, weapon) => {
      if (gameState.weaponCharges < weapon.cost) {
        return false;
        }
        gameState.weaponCharges -= weapon.cost;
        for (let i = 0; i < 3; i += 1) {
        const angle = (Math.PI * 2 * i) / 3;
        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));
        enemies.forEach((enemy) => {
          if (!enemy.alive) return;
            if (summonPos.distance(enemy.position) <= 70) {
            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());
            if (killed) {
              handleEnemyDeath(enemy);
            }
            }
        });
        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);
        }
        return true;
    }
    }
};

const gameState = {
  canvas: null,
  ctx: null,
  player: null,
  enemies: [],
  souls: [],
  particles: [],
  projectiles: [],
  alive: false,
  keys: { w: false, a: false, s: false, d: false },
  gameTime: 0,
  waveTimer: 0,
  waveNumber: 0,
  bossTimer: 0,
  bossIndex: 0,
  enemiesKilled: 0,
  difficultyMultiplier: 1,
  weaponCharges: 0,
  essenceCollected: 0,
  pendingGodsayer: false,
  screenShake: 0,
  lastTimestamp: performance.now()
};

function ensureCanvas() {
  if (!gameState.canvas) {
    gameState.canvas = document.getElementById('gameCanvas');
    if (gameState.canvas) {
      gameState.ctx = gameState.canvas.getContext('2d');
    }
    }
}

function initGame(character = 'knight') {
  ensureCanvas();
    gameState.player = new Player(character);
    gameState.enemies = [];
    gameState.souls = [];
    gameState.particles = [];
    gameState.projectiles = [];
    gameState.gameTime = 0;
    gameState.waveTimer = 0;
    gameState.waveNumber = 0;
    gameState.bossTimer = 0;
    gameState.enemiesKilled = 0;
    gameState.weaponCharges = 0;
    gameState.essenceCollected = 0;
    gameState.alive = true;
    gameState.screenShake = 0;
}

function spawnWave() {
  if (!gameState.player) {
    return;
    }
    const count = 5 + gameState.waveNumber * 2;
    for (let i = 0; i < count; i += 1) {
    const isElite = Math.random() < 0.2;
    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);
    const type = pool[Math.floor(Math.random() * pool.length)];
    const angle = Math.random() * Math.PI * 2;
    const spawnRadius = 150 + Math.random() * 100;
    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;
    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;
    gameState.enemies.push(new Enemy(type, posX, posY));
    }
    gameState.waveNumber += 1;
    gameState.waveTimer = 0;
}

function spawnBoss() {
  const bossKeys = Object.keys(BOSS_DEFS);
    const bossName = bossKeys[gameState.bossIndex % bossKeys.length];
    gameState.bossIndex += 1;
    const edge = Math.floor(Math.random() * 4);
    let x = 0;
    let y = 0;
    if (edge === 0) {
    x = Math.random() * CANVAS_WIDTH;
    y = -50;
    } else if (edge === 1) {
    x = CANVAS_WIDTH + 50;
    y = Math.random() * CANVAS_HEIGHT;
    } else if (edge === 2) {
    x = Math.random() * CANVAS_WIDTH;
    y = CANVAS_HEIGHT + 50;
    } else {
    x = -50;
    y = Math.random() * CANVAS_HEIGHT;
    }
    const boss = new Enemy(bossName, x, y, true);
    gameState.enemies.push(boss);
    gameState.bossTimer = 0;
    triggerScreenShake(20);
}

function grantEssence(amount) {
  gameState.essenceCollected += amount;
    if (gameState.essenceCollected >= 5) {
    const charges = Math.floor(gameState.essenceCollected / 5);
    gameState.weaponCharges += charges;
    gameState.essenceCollected -= charges * 5;
    }
}

function handleEnemyDeath(enemy) {
  if (!enemy) {
    return;
    }
    gameState.enemiesKilled += 1;
    if (gameState.player) {
    gameState.player.registerKill();
    }
    dropSoul(enemy);
    spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);
}

function dropSoul(enemy) {
  if (enemy.isBoss) {
    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));
    return;
    }
    if (ENEMY_DEFS[enemy.type].elite) {
    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));
    if (Math.random() < 0.4) {
      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));
    }
    } else {
    if (Math.random() < 0.95) {
      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));
    }
    if (Math.random() < 0.05) {
      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));
    }
    }
}

function spawnParticleBurst(x, y, color, type, count) {
  for (let i = 0; i < count; i += 1) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 40 + Math.random() * 120;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);
    gameState.particles.push(particle);
    }
}

function triggerScreenShake(intensity = 10) {
  gameState.screenShake = Math.max(gameState.screenShake, intensity);
}

function updateProjectiles(dt) {
  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {
    const projectile = gameState.projectiles[i];
    projectile.update(dt);
    let removed = false;
    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {
      const enemy = gameState.enemies[j];
        if (!enemy.alive) continue;
        if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {
        const killed = enemy.takeDamage(projectile.damage);
        if (killed) {
          handleEnemyDeath(enemy);
        }
        projectile.pierce -= 1;
        if (projectile.lifesteal && gameState.player) {
          gameState.player.health = Math.min(
            gameState.player.maxHealth,
            gameState.player.health + projectile.damage * projectile.lifesteal
            );
        }
        if (projectile.pierce <= 0) {
          removed = true;
            break;
        }
        }
    }
    if (projectile.isExpired() || removed) {
      gameState.projectiles.splice(i, 1);
    }
    }
}

function updateSouls(dt) {
  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {
    const soul = gameState.souls[i];
    soul.update(dt, gameState.player);
    if (soul.collected) {
      gameState.souls.splice(i, 1);
    }
    }
}

function updateParticles(dt) {
  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {
    const particle = gameState.particles[i];
    particle.update(dt);
    if (particle.remaining <= 0) {
      gameState.particles.splice(i, 1);
    }
    }
}

function updateEnemies(dt) {
  const player = gameState.player;
    for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {
    const enemy = gameState.enemies[i];
    enemy.update(dt, player, gameState.difficultyMultiplier);
    if (!enemy.alive && enemy.deathTimer > 1.5) {
      gameState.enemies.splice(i, 1);
    }
    if (enemy.alive && enemy.position.distance(player.position) <= 30) {
      const damage = enemy.damage;
        player.takeDamage(damage);
        spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);
    }
    }
}

function triggerGodsayerSword() {
  if (!gameState.player) {
    return false;
    }
    const weapon = gameState.player.manualWeapons.GodsayerSword;
    if (!weapon) {
    return false;
    }
    return weapon.trigger(gameState.player, gameState.enemies);
}

function gameLoop(dt) {
  ensureCanvas();
    if (!gameState.ctx) {
    return;
    }
    if (gameState.player && gameState.alive) {
    gameState.gameTime += dt;
    gameState.waveTimer += dt;
    gameState.bossTimer += dt;
    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;
    gameState.player.update(dt, gameState);
    updateEnemies(dt);
    updateProjectiles(dt);
    updateSouls(dt);
    updateParticles(dt);
    if (gameState.waveTimer >= 30) {
      spawnWave();
    }
    if (gameState.bossTimer >= 120) {
      spawnBoss();
    }
    if (gameState.player.health <= 0) {
      gameState.alive = false;
    }
    }
    drawGame();
    notifyHUD();
}

function drawGame() {
  const ctx = gameState.ctx;
    if (!ctx) {
    return;
    }
    ctx.save();
    if (gameState.screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * gameState.screenShake,
      (Math.random() - 0.5) * gameState.screenShake
    );
    gameState.screenShake *= 0.9;
    }
    drawBackground(ctx);
    gameState.souls.forEach((soul) => soul.draw(ctx));
    gameState.enemies.forEach((enemy) => enemy.draw(ctx));
    gameState.projectiles.forEach((projectile) => projectile.draw(ctx));
    if (gameState.player) {
    gameState.player.draw(ctx);
    }
    gameState.particles.forEach((particle) => particle.draw(ctx));
    drawHUDOverlay(ctx);
    ctx.restore();
}

function drawBackground(ctx) {
  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    gradient.addColorStop(0, '#1a0327');
    gradient.addColorStop(0.5, '#1f1f49');
    gradient.addColorStop(1, '#040308');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    for (let i = 0; i < 8; i += 1) {
    const angle = (Math.PI * 2 * i) / 8;
    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;
    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);
    ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(196,30,58,0.25)';
    ctx.beginPath();
    ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);
    ctx.stroke();
}

function drawHUDOverlay(ctx) {
  if (!gameState.player) {
    return;
    }
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(15, 15, 220, 110);
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);
    ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);
    ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);
    ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);
    ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);
    ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);
}

function notifyHUD() {
  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {
    window.updateHUD(gameState);
    }
    if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {
    window.showDeathScreen(gameState);
    }
}

function animationLoop(timestamp) {
  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);
    gameState.lastTimestamp = timestamp;
    gameLoop(dt || TARGET_DELTA);
    window.requestAnimationFrame(animationLoop);
}

window.requestAnimationFrame(animationLoop);

function setKeyState(key, isDown) {
  if (gameState.keys[key] !== undefined) {
    gameState.keys[key] = isDown;
    }
}

window.initGame = initGame;
window.triggerGodsayerSword = triggerGodsayerSword;
window.setKeyState = setKeyState;
window.gameState = gameState;
window.spawnWave = spawnWave;
window.spawnBoss = spawnBoss;
window.grantEssence = grantEssence;
window.handleEnemyDeath = handleEnemyDeath;
window.triggerScreenShake = triggerScreenShake;
```

