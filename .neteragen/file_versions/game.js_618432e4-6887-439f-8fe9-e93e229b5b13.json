{
  "file_name": "game.js",
  "revision_id": "618432e4-6887-439f-8fe9-e93e229b5b13",
  "metadata": {
    "timestamp": "2025-12-09T13:52:28.549224",
    "type": "cache_version",
    "source": "ToolTextFileEdit",
    "size": 35664,
    "is_reverted": false,
    "git_branch_name": "",
    "agent_name": "Many",
    "description": "Add complete Souls of the Abyss game.js implementation"
  },
  "content": "class Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  clone() {\n    return new Vector2(this.x, this.y);\n  }\n\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n\n  subtract(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  normalize() {\n    const len = this.length() || 1;\n    this.x /= len;\n    this.y /= len;\n    return this;\n  }\n\n  distance(other) {\n    const dx = this.x - other.x;\n    const dy = this.y - other.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angle(other) {\n    return Math.atan2(other.y - this.y, other.x - this.x);\n  }\n\n  static fromAngle(angle, magnitude = 1) {\n    return new Vector2(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\n  }\n}\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 600;\nconst TARGET_DELTA = 1 / 60;\nconst DEG_TO_RAD = Math.PI / 180;\nconst DEFAULT_ANIMATION = {\n  animations: {\n    idle: { frameCount: 1, frameTime: 1, loop: true },\n    run: { frameCount: 1, frameTime: 1, loop: true },\n    attack: { frameCount: 1, frameTime: 1, loop: false },\n    hit: { frameCount: 1, frameTime: 1, loop: false },\n    death: { frameCount: 1, frameTime: 1, loop: false }\n  }\n};\n\nconst CHARACTER_DEFS = {\n  knight: {\n    maxHealth: 100,\n    baseDamage: 12,\n    range: 110,\n    speed: 200,\n    armor: 5,\n    spriteSize: 48\n  },\n  witch: {\n    maxHealth: 70,\n    baseDamage: 8,\n    range: 140,\n    speed: 180,\n    armor: 2,\n    spriteSize: 48\n  },\n  rogue: {\n    maxHealth: 85,\n    baseDamage: 10,\n    range: 90,\n    speed: 250,\n    armor: 3,\n    spriteSize: 48,\n    dodgeChance: 0.1\n  }\n};\n\nconst ENEMY_DEFS = {\n  zombie: { health: 20, damage: 5, speed: 80, color: '#9da3a4', elite: false },\n  spectre: { health: 18, damage: 4, speed: 90, color: '#4db1e8', elite: false },\n  cultist: { health: 22, damage: 6, speed: 100, color: '#a347d6', elite: false },\n  vampire: { health: 40, damage: 10, speed: 120, color: '#c41e3a', elite: true },\n  wraith: { health: 38, damage: 9, speed: 110, color: '#1a1a1f', elite: true },\n  corrupted_knight: { health: 50, damage: 15, speed: 60, color: '#4e5b6e', elite: true },\n  warden: { health: 42, damage: 11, speed: 100, color: '#0ad1ff', elite: true }\n};\n\nconst BOSS_DEFS = {\n  shadow_lord: { health: 200, damage: 30, speed: 80, spriteSize: 96, color: '#ff304f' },\n  void_rift: { health: 250, damage: 35, speed: 70, spriteSize: 96, color: '#1b0326' },\n  ancient_one: { health: 300, damage: 40, speed: 75, spriteSize: 96, color: '#ff9f1c' }\n};\n\nconst SOUL_TYPES = {\n  ethereal: { xp: 10, color: '#f3f6ff' },\n  essence: { xp: 0, color: '#ffd95a', essence: 1 },\n  corrupted: { xp: 20, color: '#b21f35' },\n  cursed: { xp: 50, color: '#0d0d0d' }\n};\n\nconst LEVEL_WEAPON_UNLOCK = [\n  'ShatterburstAxe',\n  'SoulreaverDagger',\n  'EternalHalberd',\n  'ChaosOrb',\n  'ReapersScythe',\n  'BloodmoonLance',\n  'VoidSummoner'\n];\n\nconst spriteCache = {};\nconst animationCache = {};\n\nfunction getAnimationPath(name) {\n  return `animations/${name}.json`;\n}\n\nfunction getSprite(name, spriteSize = 48) {\n  if (spriteCache[name]) {\n    return spriteCache[name];\n  }\n  const sprite = new Sprite(\n    name,\n    `sprites/${name}.png`,\n    spriteSize,\n    spriteSize,\n    getAnimationPath(name)\n  );\n  spriteCache[name] = sprite;\n  return sprite;\n}\n\nfunction loadAnimationData(name) {\n  if (animationCache[name]) {\n    return animationCache[name];\n  }\n  animationCache[name] = DEFAULT_ANIMATION;\n  fetch(getAnimationPath(name))\n    .then((resp) => resp.json())\n    .then((data) => {\n      animationCache[name] = data.animations ? data : { animations: data };\n    })\n    .catch(() => {\n      animationCache[name] = DEFAULT_ANIMATION;\n    });\n  return animationCache[name];\n}\n\nclass Sprite {\n  constructor(name, imageUrl, frameWidth, frameHeight, animationPath) {\n    this.name = name;\n    this.image = new Image();\n    this.image.src = imageUrl;\n    this.imageLoaded = false;\n    this.imageFailed = false;\n    this.image.onload = () => {\n      this.imageLoaded = true;\n    };\n    this.image.onerror = () => {\n      this.imageFailed = true;\n    };\n    this.frameWidth = frameWidth;\n    this.frameHeight = frameHeight;\n    this.animationData = loadAnimationData(name) || DEFAULT_ANIMATION;\n    this.currentState = 'idle';\n    this.animationTime = 0;\n    this.frameIndex = 0;\n    this.colorFallback = '#ffffff';\n    this.animationPath = animationPath;\n    this.refreshAnimation();\n  }\n\n  refreshAnimation() {\n    fetch(this.animationPath)\n      .then((resp) => resp.json())\n      .then((data) => {\n        this.animationData = data.animations ? data : { animations: data };\n      })\n      .catch(() => {\n        this.animationData = DEFAULT_ANIMATION;\n      });\n  }\n\n  update(dt, desiredState = 'idle') {\n    if (this.currentState !== desiredState) {\n      this.currentState = desiredState;\n      this.animationTime = 0;\n    } else {\n      this.animationTime += dt;\n    }\n    const animSpec = this.getAnimationSpec(this.currentState);\n    const totalDuration = animSpec.frameCount * animSpec.frameTime;\n    if (animSpec.loop) {\n      this.animationTime = this.animationTime % (totalDuration || 1);\n    } else if (this.animationTime > totalDuration) {\n      this.animationTime = totalDuration - animSpec.frameTime;\n    }\n    this.frameIndex = Math.floor(this.animationTime / (animSpec.frameTime || 1)) % animSpec.frameCount;\n  }\n\n  getAnimationSpec(state) {\n    const data = this.animationData.animations || this.animationData;\n    return data[state] || data.idle || DEFAULT_ANIMATION.animations.idle;\n  }\n\n  draw(ctx, x, y, scale = 1, flipX = false) {\n    if (this.imageLoaded && !this.imageFailed) {\n      const animSpec = this.getAnimationSpec(this.currentState);\n      const framesPerRow = Math.floor(this.image.width / this.frameWidth) || 1;\n      const srcX = (this.frameIndex % framesPerRow) * this.frameWidth;\n      const srcY = 0;\n      const destWidth = this.frameWidth * scale;\n      const destHeight = this.frameHeight * scale;\n      ctx.save();\n      if (flipX) {\n        ctx.translate(x + destWidth, y);\n        ctx.scale(-1, 1);\n        ctx.drawImage(\n          this.image,\n          srcX,\n          srcY,\n          this.frameWidth,\n          this.frameHeight,\n          0,\n          0,\n          destWidth,\n          destHeight\n        );\n      } else {\n        ctx.drawImage(\n          this.image,\n          srcX,\n          srcY,\n          this.frameWidth,\n          this.frameHeight,\n          x,\n          y,\n          destWidth,\n          destHeight\n        );\n      }\n      ctx.restore();\n    } else {\n      ctx.fillStyle = this.colorFallback;\n      ctx.beginPath();\n      ctx.arc(x + this.frameWidth * 0.5, y + this.frameHeight * 0.5, this.frameWidth * 0.4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n}\n\nclass Particle {\n  constructor(x, y, vx, vy, lifetime, color, type = 'spark') {\n    this.position = new Vector2(x, y);\n    this.velocity = new Vector2(vx, vy);\n    this.lifetime = lifetime;\n    this.remaining = lifetime;\n    this.color = color;\n    this.type = type;\n    this.size = type === 'explosion' ? 10 : 4;\n  }\n\n  update(dt) {\n    this.remaining -= dt;\n    if (this.type === 'blood' || this.type === 'spark') {\n      this.velocity.y += 30 * dt;\n    }\n    this.position.add(this.velocity.clone().scale(dt));\n  }\n\n  draw(ctx) {\n    if (this.remaining <= 0) {\n      return;\n    }\n    const alpha = Math.max(this.remaining / this.lifetime, 0);\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    if (this.type === 'glow') {\n      const gradient = ctx.createRadialGradient(\n        this.position.x,\n        this.position.y,\n        0,\n        this.position.x,\n        this.position.y,\n        this.size * 2\n      );\n      gradient.addColorStop(0, this.color);\n      gradient.addColorStop(1, 'transparent');\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(this.position.x, this.position.y, this.size * 2, 0, Math.PI * 2);\n      ctx.fill();\n    } else {\n      ctx.fillStyle = this.color;\n      ctx.beginPath();\n      ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n}\n\nclass Projectile {\n  constructor(config) {\n    this.position = config.position.clone();\n    this.velocity = config.velocity.clone();\n    this.damage = config.damage;\n    this.range = config.range;\n    this.traveled = 0;\n    this.radius = config.radius || 6;\n    this.pierce = config.pierce || 1;\n    this.owner = config.owner;\n    this.lifesteal = config.lifesteal || 0;\n    this.color = config.color || '#ffffff';\n  }\n\n  update(dt) {\n    const movement = this.velocity.clone().scale(dt);\n    this.position.add(movement);\n    this.traveled += movement.length();\n  }\n\n  isExpired() {\n    return this.traveled >= this.range;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nclass Soul {\n  constructor(x, y, type) {\n    this.position = new Vector2(x, y);\n    this.type = type;\n    this.radius = 8;\n    this.floatTimer = 0;\n    this.collected = false;\n  }\n\n  update(dt, player) {\n    this.floatTimer += dt;\n    const bob = Math.sin(this.floatTimer * 3) * 2;\n    if (player && player.position.distance(this.position) < 25) {\n      this.collected = true;\n      player.gainExperience(SOUL_TYPES[this.type].xp || 0);\n      if (SOUL_TYPES[this.type].essence) {\n        grantEssence(SOUL_TYPES[this.type].essence);\n      }\n    }\n    this.renderOffset = bob;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = SOUL_TYPES[this.type].color;\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y + this.renderOffset, this.radius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nclass Weapon {\n  constructor(name, config) {\n    this.name = name;\n    this.damage = config.damage;\n    this.fireRate = config.fireRate || 1;\n    this.range = config.range || 100;\n    this.type = config.type;\n    this.cost = config.cost || 0;\n    this.manual = config.manual || false;\n    this.cooldown = 0;\n    this.execute = config.execute;\n    this.lifesteal = config.lifesteal || 0;\n    this.extra = config.extra || {};\n  }\n\n  update(dt, player, enemies) {\n    if (this.manual) {\n      return;\n    }\n    this.cooldown -= dt;\n    if (this.cooldown <= 0) {\n      const fired = this.execute(player, enemies, this);\n      if (fired) {\n        this.cooldown = 1 / this.fireRate;\n      }\n    }\n  }\n\n  trigger(player, enemies) {\n    return this.execute(player, enemies, this);\n  }\n}\n\nclass Enemy {\n  constructor(type, x, y, isBoss = false) {\n    this.type = type;\n    this.isBoss = isBoss;\n    this.definition = isBoss ? BOSS_DEFS[type] : ENEMY_DEFS[type];\n    this.maxHealth = this.definition.health;\n    this.health = this.maxHealth;\n    this.damage = this.definition.damage;\n    this.speed = this.definition.speed;\n    this.position = new Vector2(x, y);\n    this.velocity = new Vector2();\n    this.alive = true;\n    this.state = 'idle';\n    this.deathTimer = 0;\n    this.sprite = getSprite(type, this.definition.spriteSize || 48);\n    this.sprite.colorFallback = this.definition.color;\n  }\n\n  update(dt, player, multiplier) {\n    if (!this.alive) {\n      this.deathTimer += dt;\n      this.sprite.update(dt, 'death');\n      return;\n    }\n    const toPlayer = new Vector2(player.position.x - this.position.x, player.position.y - this.position.y);\n    const distance = Math.max(toPlayer.length(), 0.0001);\n    const direction = toPlayer.clone().scale(1 / distance);\n    const effectiveSpeed = this.speed * multiplier;\n    if (this.type === 'wraith') {\n      const swirl = new Vector2(-direction.y, direction.x).scale(Math.sin(gameState.gameTime * 2) * 40);\n      direction.add(swirl).normalize();\n    }\n    this.velocity = direction.clone().scale(effectiveSpeed);\n    this.position.add(this.velocity.clone().scale(dt));\n    this.sprite.update(dt, distance > 5 ? 'run' : 'attack');\n  }\n\n  takeDamage(amount) {\n    if (!this.alive) {\n      return false;\n    }\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n      this.state = 'death';\n      return true;\n    }\n    this.state = 'hit';\n    return false;\n  }\n\n  draw(ctx) {\n    const size = this.definition.spriteSize || 48;\n    const drawX = this.position.x - size * 0.5;\n    const drawY = this.position.y - size * 0.5;\n    this.sprite.update(TARGET_DELTA, this.state === 'death' ? 'death' : this.state === 'hit' ? 'hit' : 'run');\n    this.sprite.draw(ctx, drawX, drawY, this.isBoss ? 2 : 1);\n    if (this.alive) {\n      ctx.fillStyle = '#222';\n      ctx.fillRect(drawX, drawY - 10, size, 4);\n      ctx.fillStyle = '#e63946';\n      const hpRatio = Math.max(this.health / this.maxHealth, 0);\n      ctx.fillRect(drawX, drawY - 10, size * hpRatio, 4);\n    }\n  }\n}\n\nclass Player {\n  constructor(character) {\n    const def = CHARACTER_DEFS[character];\n    this.character = character;\n    this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n    this.velocity = new Vector2();\n    this.speed = def.speed;\n    this.range = def.range;\n    this.maxHealth = def.maxHealth;\n    this.health = def.maxHealth;\n    this.baseDamage = def.baseDamage;\n    this.level = 1;\n    this.experience = 0;\n    this.nextLevelExp = 100;\n    this.armor = def.armor || 0;\n    this.sprite = getSprite(character, def.spriteSize);\n    this.sprite.colorFallback = '#f5f3f4';\n    this.state = 'idle';\n    this.killStreak = 0;\n    this.killStreakTimer = 0;\n    this.killStreakActive = false;\n    this.killStreakDuration = 5;\n    this.weapons = [];\n    this.manualWeapons = {};\n    this.unlockWeapon('CursedBlade');\n    this.unlockWeapon('GodsayerSword');\n    this.unlockWeapon('ShatterburstAxe');\n    this.unlockWeapon('SoulreaverDagger');\n    this.unlockWeapon('EternalHalberd');\n    this.unlockWeapon('ChaosOrb');\n    this.unlockWeapon('ReapersScythe');\n    this.unlockWeapon('BloodmoonLance');\n    this.unlockWeapon('VoidSummoner');\n    this.weapons = this.weapons.filter((w) => !w.manual);\n    this.sprite.refreshAnimation();\n  }\n\n  unlockWeapon(name) {\n    if (!WEAPON_CONFIGS[name]) {\n      return;\n    }\n    const weapon = new Weapon(name, WEAPON_CONFIGS[name]);\n    if (weapon.manual) {\n      this.manualWeapons[name] = weapon;\n    } else {\n      this.weapons.push(weapon);\n    }\n  }\n\n  update(dt, state) {\n    const keys = state.keys;\n    const input = new Vector2(\n      (keys.d ? 1 : 0) - (keys.a ? 1 : 0),\n      (keys.s ? 1 : 0) - (keys.w ? 1 : 0)\n    );\n    if (input.length() > 0) {\n      input.normalize();\n      this.velocity = input.clone().scale(this.speed);\n      this.state = 'run';\n    } else {\n      this.velocity = new Vector2();\n      this.state = 'idle';\n    }\n    this.position.add(this.velocity.clone().scale(dt));\n    this.position.x = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.position.x));\n    this.position.y = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.position.y));\n    this.weapons.forEach((weapon) => weapon.update(dt, this, state.enemies));\n    if (this.killStreakActive) {\n      this.killStreakTimer -= dt;\n      if (this.killStreakTimer <= 0) {\n        this.killStreakActive = false;\n        this.killStreak = 0;\n      }\n    }\n    this.sprite.update(dt, this.state);\n  }\n\n  takeDamage(amount) {\n    if (this.character === 'rogue' && Math.random() < 0.1) {\n      spawnParticleBurst(this.position.x, this.position.y, '#5f1e8f', 'glow', 6);\n      return;\n    }\n    const mitigated = Math.max(amount - this.armor, 1);\n    this.health -= mitigated;\n    if (this.health <= 0) {\n      this.health = 0;\n      gameState.alive = false;\n    }\n  }\n\n  gainExperience(amount) {\n    this.experience += amount;\n    while (this.experience >= this.nextLevelExp) {\n      this.experience -= this.nextLevelExp;\n      this.level += 1;\n      this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);\n      this.maxHealth += 5;\n      this.health = this.maxHealth;\n      if (this.character === 'knight') {\n        this.armor += 1;\n      }\n      if (this.level >= 3 && LEVEL_WEAPON_UNLOCK.length > 0) {\n        const weaponName = LEVEL_WEAPON_UNLOCK.shift();\n        if (weaponName) {\n          this.unlockWeapon(weaponName);\n        }\n      }\n    }\n  }\n\n  registerKill() {\n    this.killStreak += 1;\n    if (this.character === 'rogue' && this.killStreak >= 5) {\n      this.killStreakActive = true;\n      this.killStreakTimer = this.killStreakDuration;\n    }\n  }\n\n  getDamageMultiplier() {\n    let multiplier = 1 + (this.level - 1) * 0.05;\n    if (this.killStreakActive) {\n      multiplier += 0.15;\n    }\n    return multiplier;\n  }\n\n  draw(ctx) {\n    const size = CHARACTER_DEFS[this.character].spriteSize;\n    const drawX = this.position.x - size * 0.5;\n    const drawY = this.position.y - size * 0.5;\n    this.sprite.draw(ctx, drawX, drawY, 1, this.velocity.x < 0);\n    ctx.fillStyle = '#222';\n    ctx.fillRect(drawX, drawY - 12, size, 5);\n    ctx.fillStyle = '#7cf5ff';\n    ctx.fillRect(drawX, drawY - 12, size * (this.health / this.maxHealth), 5);\n  }\n}\n\nconst WEAPON_CONFIGS = {\n  CursedBlade: {\n    damage: 10,\n    fireRate: 1,\n    range: 100,\n    type: 'cone',\n    execute: (player, enemies, weapon) => {\n      let hit = false;\n      const facingAngle = Math.atan2(player.velocity.y, player.velocity.x) || 0;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) {\n          return;\n        }\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const angleToEnemy = Math.atan2(\n            enemy.position.y - player.position.y,\n            enemy.position.x - player.position.x\n          );\n          let delta = angleToEnemy - facingAngle;\n          while (delta > Math.PI) delta -= Math.PI * 2;\n          while (delta < -Math.PI) delta += Math.PI * 2;\n          if (Math.abs(delta) <= 50 * DEG_TO_RAD || player.velocity.length() === 0) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            hit = hit || killed;\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n          }\n        }\n      });\n      if (hit) {\n        spawnParticleBurst(player.position.x, player.position.y, '#ff4d6d', 'slash', 8);\n      }\n      return true;\n    }\n  },\n  ShatterburstAxe: {\n    damage: 15,\n    fireRate: 0.8,\n    range: 60,\n    type: 'aoe',\n    execute: (player, enemies, weapon) => {\n      let any = false;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        if (player.position.distance(enemy.position) <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          any = any || killed;\n          if (killed) {\n            handleEnemyDeath(enemy);\n          } else {\n            const push = enemy.position.clone().subtract(player.position).normalize().scale(80);\n            enemy.position.add(push);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#ffa600', 'explosion', 12);\n      return true;\n    }\n  },\n  SoulreaverDagger: {\n    damage: 5,\n    fireRate: 2,\n    range: 30,\n    type: 'multi-hit',\n    execute: (player, enemies, weapon) => {\n      let target = null;\n      let closest = Infinity;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance < closest && distance <= weapon.range) {\n          closest = distance;\n          target = enemy;\n        }\n      });\n      if (!target) {\n        return false;\n      }\n      for (let i = 0; i < 3; i += 1) {\n        const killed = target.takeDamage(weapon.damage * player.getDamageMultiplier());\n        if (killed) {\n          handleEnemyDeath(target);\n          break;\n        }\n        player.health = Math.min(\n          player.maxHealth,\n          player.health + weapon.damage * 0.2 * player.getDamageMultiplier()\n        );\n      }\n      spawnParticleBurst(target.position.x, target.position.y, '#ff6f91', 'blood', 6);\n      return true;\n    }\n  },\n  EternalHalberd: {\n    damage: 25,\n    fireRate: 0.5,\n    range: 80,\n    type: 'aoe',\n    execute: (player, enemies, weapon) => {\n      let hitAny = false;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          hitAny = hitAny || killed;\n          const pull = player.position.clone().subtract(enemy.position).normalize().scale(120);\n          enemy.position.add(pull.scale(0.1));\n          if (killed) {\n            handleEnemyDeath(enemy);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#c5cbe3', 'glow', 10);\n      return true;\n    }\n  },\n  ChaosOrb: {\n    damage: 8,\n    fireRate: 1.2,\n    range: 300,\n    type: 'projectile',\n    execute: (player) => {\n      const orbCount = 2 + Math.floor(Math.random() * 3);\n      for (let i = 0; i < orbCount; i += 1) {\n        const angle = Math.random() * Math.PI * 2;\n        const velocity = Vector2.fromAngle(angle, 200);\n        gameState.projectiles.push(\n          new Projectile({\n            position: player.position.clone(),\n            velocity,\n            damage: 8 * player.getDamageMultiplier(),\n            range: 320,\n            pierce: 3,\n            owner: player,\n            color: '#7bed9f'\n          })\n        );\n      }\n      return true;\n    }\n  },\n  ReapersScythe: {\n    damage: 20,\n    fireRate: 0.8,\n    range: 100,\n    type: 'spin',\n    execute: (player, enemies, weapon) => {\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const distance = player.position.distance(enemy.position);\n        if (distance <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          if (killed) {\n            handleEnemyDeath(enemy);\n          } else {\n            const pull = player.position.clone().subtract(enemy.position).normalize().scale(50);\n            enemy.position.add(pull);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#ff4f00', 'slash', 16);\n      return true;\n    }\n  },\n  BloodmoonLance: {\n    damage: 20,\n    fireRate: 1,\n    range: 400,\n    type: 'beam',\n    lifesteal: 0.5,\n    execute: (player, enemies, weapon) => {\n      const direction = player.velocity.length() > 0 ? player.velocity.clone().normalize() : new Vector2(1, 0);\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        const toEnemy = enemy.position.clone().subtract(player.position);\n        const projection = toEnemy.x * direction.x + toEnemy.y * direction.y;\n        if (projection >= 0 && projection <= weapon.range) {\n          const perpendicular = Math.abs(toEnemy.x * direction.y - toEnemy.y * direction.x);\n          if (perpendicular <= 40) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n            player.health = Math.min(\n              player.maxHealth,\n              player.health + weapon.damage * weapon.lifesteal\n            );\n          }\n        }\n      });\n      spawnParticleBurst(\n        player.position.x + direction.x * 60,\n        player.position.y + direction.y * 60,\n        '#ff99c8',\n        'glow',\n        14\n      );\n      return true;\n    }\n  },\n  GodsayerSword: {\n    damage: 100,\n    fireRate: 1,\n    range: 150,\n    type: 'manual',\n    manual: true,\n    cost: 1,\n    execute: (player, enemies, weapon) => {\n      if (gameState.weaponCharges < weapon.cost) {\n        return false;\n      }\n      gameState.weaponCharges -= weapon.cost;\n      enemies.forEach((enemy) => {\n        if (!enemy.alive) return;\n        if (player.position.distance(enemy.position) <= weapon.range) {\n          const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n          if (killed) {\n            handleEnemyDeath(enemy);\n          }\n        }\n      });\n      spawnParticleBurst(player.position.x, player.position.y, '#f1c40f', 'explosion', 25);\n      triggerScreenShake();\n      return true;\n    }\n  },\n  VoidSummoner: {\n    damage: 15,\n    fireRate: 0.125,\n    range: 200,\n    cost: 2,\n    type: 'summon',\n    execute: (player, enemies, weapon) => {\n      if (gameState.weaponCharges < weapon.cost) {\n        return false;\n      }\n      gameState.weaponCharges -= weapon.cost;\n      for (let i = 0; i < 3; i += 1) {\n        const angle = (Math.PI * 2 * i) / 3;\n        const summonPos = player.position.clone().add(Vector2.fromAngle(angle, weapon.range));\n        enemies.forEach((enemy) => {\n          if (!enemy.alive) return;\n          if (summonPos.distance(enemy.position) <= 70) {\n            const killed = enemy.takeDamage(weapon.damage * player.getDamageMultiplier());\n            if (killed) {\n              handleEnemyDeath(enemy);\n            }\n          }\n        });\n        spawnParticleBurst(summonPos.x, summonPos.y, '#5f0f40', 'glow', 12);\n      }\n      return true;\n    }\n  }\n};\n\nconst gameState = {\n  canvas: null,\n  ctx: null,\n  player: null,\n  enemies: [],\n  souls: [],\n  particles: [],\n  projectiles: [],\n  alive: false,\n  keys: { w: false, a: false, s: false, d: false },\n  gameTime: 0,\n  waveTimer: 0,\n  waveNumber: 0,\n  bossTimer: 0,\n  bossIndex: 0,\n  enemiesKilled: 0,\n  difficultyMultiplier: 1,\n  weaponCharges: 0,\n  essenceCollected: 0,\n  pendingGodsayer: false,\n  screenShake: 0,\n  lastTimestamp: performance.now()\n};\n\nfunction ensureCanvas() {\n  if (!gameState.canvas) {\n    gameState.canvas = document.getElementById('gameCanvas');\n    if (gameState.canvas) {\n      gameState.ctx = gameState.canvas.getContext('2d');\n    }\n  }\n}\n\nfunction initGame(character = 'knight') {\n  ensureCanvas();\n  gameState.player = new Player(character);\n  gameState.enemies = [];\n  gameState.souls = [];\n  gameState.particles = [];\n  gameState.projectiles = [];\n  gameState.gameTime = 0;\n  gameState.waveTimer = 0;\n  gameState.waveNumber = 0;\n  gameState.bossTimer = 0;\n  gameState.enemiesKilled = 0;\n  gameState.weaponCharges = 0;\n  gameState.essenceCollected = 0;\n  gameState.alive = true;\n  gameState.screenShake = 0;\n}\n\nfunction spawnWave() {\n  if (!gameState.player) {\n    return;\n  }\n  const count = 5 + gameState.waveNumber * 2;\n  for (let i = 0; i < count; i += 1) {\n    const isElite = Math.random() < 0.2;\n    const pool = Object.keys(ENEMY_DEFS).filter((key) => ENEMY_DEFS[key].elite === isElite);\n    const type = pool[Math.floor(Math.random() * pool.length)];\n    const angle = Math.random() * Math.PI * 2;\n    const spawnRadius = 150 + Math.random() * 100;\n    const posX = gameState.player.position.x + Math.cos(angle) * spawnRadius;\n    const posY = gameState.player.position.y + Math.sin(angle) * spawnRadius;\n    gameState.enemies.push(new Enemy(type, posX, posY));\n  }\n  gameState.waveNumber += 1;\n  gameState.waveTimer = 0;\n}\n\nfunction spawnBoss() {\n  const bossKeys = Object.keys(BOSS_DEFS);\n  const bossName = bossKeys[gameState.bossIndex % bossKeys.length];\n  gameState.bossIndex += 1;\n  const edge = Math.floor(Math.random() * 4);\n  let x = 0;\n  let y = 0;\n  if (edge === 0) {\n    x = Math.random() * CANVAS_WIDTH;\n    y = -50;\n  } else if (edge === 1) {\n    x = CANVAS_WIDTH + 50;\n    y = Math.random() * CANVAS_HEIGHT;\n  } else if (edge === 2) {\n    x = Math.random() * CANVAS_WIDTH;\n    y = CANVAS_HEIGHT + 50;\n  } else {\n    x = -50;\n    y = Math.random() * CANVAS_HEIGHT;\n  }\n  const boss = new Enemy(bossName, x, y, true);\n  gameState.enemies.push(boss);\n  gameState.bossTimer = 0;\n  triggerScreenShake(20);\n}\n\nfunction grantEssence(amount) {\n  gameState.essenceCollected += amount;\n  if (gameState.essenceCollected >= 5) {\n    const charges = Math.floor(gameState.essenceCollected / 5);\n    gameState.weaponCharges += charges;\n    gameState.essenceCollected -= charges * 5;\n  }\n}\n\nfunction handleEnemyDeath(enemy) {\n  if (!enemy) {\n    return;\n  }\n  gameState.enemiesKilled += 1;\n  if (gameState.player) {\n    gameState.player.registerKill();\n  }\n  dropSoul(enemy);\n  spawnParticleBurst(enemy.position.x, enemy.position.y, enemy.definition.color, 'blood', 10);\n}\n\nfunction dropSoul(enemy) {\n  if (enemy.isBoss) {\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'cursed'));\n    return;\n  }\n  if (ENEMY_DEFS[enemy.type].elite) {\n    gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'corrupted'));\n    if (Math.random() < 0.4) {\n      gameState.souls.push(new Soul(enemy.position.x + 10, enemy.position.y, 'essence'));\n    }\n  } else {\n    if (Math.random() < 0.95) {\n      gameState.souls.push(new Soul(enemy.position.x, enemy.position.y, 'ethereal'));\n    }\n    if (Math.random() < 0.05) {\n      gameState.souls.push(new Soul(enemy.position.x + 6, enemy.position.y, 'essence'));\n    }\n  }\n}\n\nfunction spawnParticleBurst(x, y, color, type, count) {\n  for (let i = 0; i < count; i += 1) {\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 40 + Math.random() * 120;\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    const particle = new Particle(x, y, vx, vy, 0.6 + Math.random() * 0.4, color, type);\n    gameState.particles.push(particle);\n  }\n}\n\nfunction triggerScreenShake(intensity = 10) {\n  gameState.screenShake = Math.max(gameState.screenShake, intensity);\n}\n\nfunction updateProjectiles(dt) {\n  for (let i = gameState.projectiles.length - 1; i >= 0; i -= 1) {\n    const projectile = gameState.projectiles[i];\n    projectile.update(dt);\n    let removed = false;\n    for (let j = gameState.enemies.length - 1; j >= 0; j -= 1) {\n      const enemy = gameState.enemies[j];\n      if (!enemy.alive) continue;\n      if (projectile.position.distance(enemy.position) <= projectile.radius + 20) {\n        const killed = enemy.takeDamage(projectile.damage);\n        if (killed) {\n          handleEnemyDeath(enemy);\n        }\n        projectile.pierce -= 1;\n        if (projectile.lifesteal && gameState.player) {\n          gameState.player.health = Math.min(\n            gameState.player.maxHealth,\n            gameState.player.health + projectile.damage * projectile.lifesteal\n          );\n        }\n        if (projectile.pierce <= 0) {\n          removed = true;\n          break;\n        }\n      }\n    }\n    if (projectile.isExpired() || removed) {\n      gameState.projectiles.splice(i, 1);\n    }\n  }\n}\n\nfunction updateSouls(dt) {\n  for (let i = gameState.souls.length - 1; i >= 0; i -= 1) {\n    const soul = gameState.souls[i];\n    soul.update(dt, gameState.player);\n    if (soul.collected) {\n      gameState.souls.splice(i, 1);\n    }\n  }\n}\n\nfunction updateParticles(dt) {\n  for (let i = gameState.particles.length - 1; i >= 0; i -= 1) {\n    const particle = gameState.particles[i];\n    particle.update(dt);\n    if (particle.remaining <= 0) {\n      gameState.particles.splice(i, 1);\n    }\n  }\n}\n\nfunction updateEnemies(dt) {\n  const player = gameState.player;\n  for (let i = gameState.enemies.length - 1; i >= 0; i -= 1) {\n    const enemy = gameState.enemies[i];\n    enemy.update(dt, player, gameState.difficultyMultiplier);\n    if (!enemy.alive && enemy.deathTimer > 1.5) {\n      gameState.enemies.splice(i, 1);\n    }\n    if (enemy.alive && enemy.position.distance(player.position) <= 30) {\n      const damage = enemy.damage;\n      player.takeDamage(damage);\n      spawnParticleBurst(player.position.x, player.position.y, '#ff5d73', 'blood', 5);\n    }\n  }\n}\n\nfunction triggerGodsayerSword() {\n  if (!gameState.player) {\n    return false;\n  }\n  const weapon = gameState.player.manualWeapons.GodsayerSword;\n  if (!weapon) {\n    return false;\n  }\n  return weapon.trigger(gameState.player, gameState.enemies);\n}\n\nfunction gameLoop(dt) {\n  ensureCanvas();\n  if (!gameState.ctx) {\n    return;\n  }\n  if (gameState.player && gameState.alive) {\n    gameState.gameTime += dt;\n    gameState.waveTimer += dt;\n    gameState.bossTimer += dt;\n    gameState.difficultyMultiplier = 1 + gameState.gameTime / 4;\n    gameState.player.update(dt, gameState);\n    updateEnemies(dt);\n    updateProjectiles(dt);\n    updateSouls(dt);\n    updateParticles(dt);\n    if (gameState.waveTimer >= 30) {\n      spawnWave();\n    }\n    if (gameState.bossTimer >= 120) {\n      spawnBoss();\n    }\n    if (gameState.player.health <= 0) {\n      gameState.alive = false;\n    }\n  }\n  drawGame();\n  notifyHUD();\n}\n\nfunction drawGame() {\n  const ctx = gameState.ctx;\n  if (!ctx) {\n    return;\n  }\n  ctx.save();\n  if (gameState.screenShake > 0) {\n    ctx.translate(\n      (Math.random() - 0.5) * gameState.screenShake,\n      (Math.random() - 0.5) * gameState.screenShake\n    );\n    gameState.screenShake *= 0.9;\n  }\n  drawBackground(ctx);\n  gameState.souls.forEach((soul) => soul.draw(ctx));\n  gameState.enemies.forEach((enemy) => enemy.draw(ctx));\n  gameState.projectiles.forEach((projectile) => projectile.draw(ctx));\n  if (gameState.player) {\n    gameState.player.draw(ctx);\n  }\n  gameState.particles.forEach((particle) => particle.draw(ctx));\n  drawHUDOverlay(ctx);\n  ctx.restore();\n}\n\nfunction drawBackground(ctx) {\n  const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\n  gradient.addColorStop(0, '#1a0327');\n  gradient.addColorStop(0.5, '#1f1f49');\n  gradient.addColorStop(1, '#040308');\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n  ctx.strokeStyle = 'rgba(255,255,255,0.08)';\n  for (let i = 0; i < 8; i += 1) {\n    const angle = (Math.PI * 2 * i) / 8;\n    const cx = CANVAS_WIDTH / 2 + Math.cos(angle) * 200;\n    const cy = CANVAS_HEIGHT / 2 + Math.sin(angle) * 120;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, 20, 50, angle, 0, Math.PI * 2);\n    ctx.stroke();\n  }\n  ctx.strokeStyle = 'rgba(196,30,58,0.25)';\n  ctx.beginPath();\n  ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 120, 0, Math.PI * 2);\n  ctx.stroke();\n}\n\nfunction drawHUDOverlay(ctx) {\n  if (!gameState.player) {\n    return;\n  }\n  ctx.fillStyle = 'rgba(0,0,0,0.35)';\n  ctx.fillRect(15, 15, 220, 110);\n  ctx.fillStyle = '#ffffff';\n  ctx.font = '14px \"Segoe UI\", sans-serif';\n  ctx.fillText(`Time: ${gameState.gameTime.toFixed(1)}s`, 25, 35);\n  ctx.fillText(`Level: ${gameState.player.level}`, 25, 55);\n  ctx.fillText(`Wave: ${gameState.waveNumber}`, 25, 75);\n  ctx.fillText(`Enemies: ${gameState.enemies.filter((e) => e.alive).length}`, 25, 95);\n  ctx.fillText(`Essence: ${gameState.weaponCharges} (+${gameState.essenceCollected}/5)`, 25, 115);\n  ctx.fillText(`Boss in: ${(120 - gameState.bossTimer).toFixed(1)}s`, 25, 135);\n}\n\nfunction notifyHUD() {\n  if (typeof window !== 'undefined' && typeof window.updateHUD === 'function') {\n    window.updateHUD(gameState);\n  }\n  if (!gameState.alive && typeof window !== 'undefined' && typeof window.showDeathScreen === 'function') {\n    window.showDeathScreen(gameState);\n  }\n}\n\nfunction animationLoop(timestamp) {\n  const dt = Math.min((timestamp - gameState.lastTimestamp) / 1000, 0.1);\n  gameState.lastTimestamp = timestamp;\n  gameLoop(dt || TARGET_DELTA);\n  window.requestAnimationFrame(animationLoop);\n}\n\nwindow.requestAnimationFrame(animationLoop);\n\nfunction setKeyState(key, isDown) {\n  if (gameState.keys[key] !== undefined) {\n    gameState.keys[key] = isDown;\n  }\n}\n\nwindow.initGame = initGame;\nwindow.triggerGodsayerSword = triggerGodsayerSword;\nwindow.setKeyState = setKeyState;\nwindow.gameState = gameState;\nwindow.spawnWave = spawnWave;\nwindow.spawnBoss = spawnBoss;\nwindow.grantEssence = grantEssence;\nwindow.handleEnemyDeath = handleEnemyDeath;\nwindow.triggerScreenShake = triggerScreenShake;\n",
  "saved_at": "2025-12-09T13:52:28.549224"
}